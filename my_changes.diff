diff --git a/Core/Inc/app_conf.h b/Core/Inc/app_conf.h
index 88d8006..07f064e 100644
--- a/Core/Inc/app_conf.h
+++ b/Core/Inc/app_conf.h
@@ -50,7 +50,7 @@
 /**
  * Define Advertising parameters
  */
-#define CFG_PUBLIC_BD_ADDRESS               (0xF1D000000006)
+#define CFG_PUBLIC_BD_ADDRESS               (0xF1D000000014)
 #define CFG_BD_ADDRESS_TYPE                 HCI_ADDR_PUBLIC
 #define CFG_BLE_PRIVACY_ENABLED             (0)
 
diff --git a/Core/Inc/motion_logger.h b/Core/Inc/motion_logger.h
new file mode 100644
index 0000000..e592c2a
--- /dev/null
+++ b/Core/Inc/motion_logger.h
@@ -0,0 +1,33 @@
+#ifndef MOTION_LOGGER_H
+#define MOTION_LOGGER_H
+
+#include "main.h"
+#include "stm32wb0x_hal.h"
+
+/* Maximum number of events to store */
+#define MAX_MOTION_EVENTS 100
+
+/* Motion types */
+typedef enum {
+    MOTION_TYPE_NONE = 0,
+    MOTION_TYPE_SMALL = 1,
+    MOTION_TYPE_MEDIUM = 2,
+    MOTION_TYPE_LARGE = 3
+} MotionType_t;
+
+/* Motion event structure */
+typedef struct {
+    RTC_TimeTypeDef time;
+    RTC_DateTypeDef date;
+    MotionType_t motionType;
+    uint8_t valid;  // 1 if entry is valid, 0 if empty
+} MotionEvent_t;
+
+/* Function prototypes */
+void MotionLogger_Init(RTC_HandleTypeDef *hrtc);
+uint8_t MotionLogger_LogEvent(MotionType_t motionType);
+uint16_t MotionLogger_GetEventCount(void);
+MotionEvent_t* MotionLogger_GetEvent(uint16_t index);
+void MotionLogger_Clear(void);
+
+#endif // MOTION_LOGGER_H
diff --git a/Core/Inc/stm32wb0x_hal_conf.h b/Core/Inc/stm32wb0x_hal_conf.h
index 8741221..76e3b27 100644
--- a/Core/Inc/stm32wb0x_hal_conf.h
+++ b/Core/Inc/stm32wb0x_hal_conf.h
@@ -44,7 +44,7 @@
 #define HAL_RADIO_MODULE_ENABLED
 #define HAL_RADIO_TIMER_MODULE_ENABLED
 #define HAL_RNG_MODULE_ENABLED
-/*#define HAL_RTC_MODULE_ENABLED   */
+#define HAL_RTC_MODULE_ENABLED
 /*#define HAL_SMARTCARD_MODULE_ENABLED   */
 /*#define HAL_SMBUS_MODULE_ENABLED   */
 /*#define HAL_SPI_MODULE_ENABLED   */
diff --git a/Core/Src/main.c b/Core/Src/main.c
index 9c13409..1ade6cf 100644
--- a/Core/Src/main.c
+++ b/Core/Src/main.c
@@ -27,6 +27,7 @@
 #include "accelerometer.h"
 #include "power_management.h"
 #include "sound.h"
+#include "motion_logger.h"
 #include "lights.h"
 #include <string.h>
 #include <stdio.h>
@@ -57,6 +58,8 @@ PKA_HandleTypeDef hpka;
 
 RNG_HandleTypeDef hrng;
 
+RTC_HandleTypeDef hrtc;
+
 TIM_HandleTypeDef htim2;
 
 UART_HandleTypeDef huart1;
@@ -74,6 +77,7 @@ static void MX_RNG_Init(void);
 static void MX_PKA_Init(void);
 static void MX_RADIO_Init(void);
 static void MX_RADIO_TIMER_Init(void);
+static void MX_RTC_Init(void);
 /* USER CODE BEGIN PFP */
 
 /* USER CODE END PFP */
@@ -153,7 +157,9 @@ int main(void)
   MX_PKA_Init();
   MX_RADIO_Init();
   MX_RADIO_TIMER_Init();
+  MX_RTC_Init();
   /* USER CODE BEGIN 2 */
+  MotionLogger_Init(&hrtc);  // Pass your RTC handle
   HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
   HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
   firstBootTone();
@@ -163,13 +169,10 @@ int main(void)
 
   // Safe boot mode in case of sleep loop
   if (HAL_GPIO_ReadPin(GPIOB, CHARGE_Pin) == 0){
-	  playTone(400,20);
-	  playTone(500,30);
-	  playTone(600,50);
 	  while(HAL_GPIO_ReadPin(GPIOB, CHARGE_Pin) == 0);
-	  playTone(600,50);
-	  playTone(500,30);
-	  playTone(400,20);
+	  playTone(300,50);
+	  playTone(200,30);
+	  playTone(100,20);
   } else {
 	  //Enter_Sleep_Mode_Optimized();
   }
@@ -417,6 +420,69 @@ static void MX_RNG_Init(void)
 
 }
 
+/**
+  * @brief RTC Initialization Function
+  * @param None
+  * @retval None
+  */
+static void MX_RTC_Init(void)
+{
+
+  /* USER CODE BEGIN RTC_Init 0 */
+
+  /* USER CODE END RTC_Init 0 */
+
+  RTC_TimeTypeDef sTime = {0};
+  RTC_DateTypeDef sDate = {0};
+
+  /* USER CODE BEGIN RTC_Init 1 */
+
+  /* USER CODE END RTC_Init 1 */
+
+  /** Initialize RTC Only
+  */
+  hrtc.Instance = RTC;
+  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
+  hrtc.Init.AsynchPrediv = 127;
+  hrtc.Init.SynchPrediv = 255;
+  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
+  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
+  if (HAL_RTC_Init(&hrtc) != HAL_OK)
+  {
+    Error_Handler();
+  }
+
+  /* USER CODE BEGIN Check_RTC_BKUP */
+
+  /* USER CODE END Check_RTC_BKUP */
+
+  /** Initialize RTC and set the Time and Date
+  */
+  sTime.Hours = 0x11;
+  sTime.Minutes = 0x56;
+  sTime.Seconds = 0x30;
+  sTime.SubSeconds = 0x0;
+  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
+  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
+  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  sDate.WeekDay = RTC_WEEKDAY_TUESDAY;
+  sDate.Month = RTC_MONTH_JANUARY;
+  sDate.Date = 0x13;
+  sDate.Year = 0x26;
+
+  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
+  {
+    Error_Handler();
+  }
+  /* USER CODE BEGIN RTC_Init 2 */
+
+  /* USER CODE END RTC_Init 2 */
+
+}
+
 /**
   * @brief TIM2 Initialization Function
   * @param None
diff --git a/Core/Src/motion_logger.c b/Core/Src/motion_logger.c
new file mode 100644
index 0000000..9173f37
--- /dev/null
+++ b/Core/Src/motion_logger.c
@@ -0,0 +1,99 @@
+#include "motion_logger.h"
+#include <stdio.h>
+
+/* Private variables */
+static MotionEvent_t motionEvents[MAX_MOTION_EVENTS];
+static uint16_t eventCount = 0;
+static uint16_t nextIndex = 0;
+static RTC_HandleTypeDef *hrtc_handle = NULL;
+
+/**
+ * @brief Initialize the motion logger
+ * @param hrtc Pointer to RTC handle
+ */
+void MotionLogger_Init(RTC_HandleTypeDef *hrtc)
+{
+    hrtc_handle = hrtc;
+    MotionLogger_Clear();
+}
+
+/**
+ * @brief Log a motion event with current timestamp
+ * @param motionType Type of motion detected
+ * @return 1 if successful, 0 if buffer full
+ */
+uint8_t MotionLogger_LogEvent(MotionType_t motionType)
+{
+    if (hrtc_handle == NULL) {
+        return 0;  // Not initialized
+    }
+
+    // Get current time and date from RTC
+    HAL_RTC_GetTime(hrtc_handle, &motionEvents[nextIndex].time, RTC_FORMAT_BIN);
+    HAL_RTC_GetDate(hrtc_handle, &motionEvents[nextIndex].date, RTC_FORMAT_BIN);
+
+    // Store motion type
+    motionEvents[nextIndex].motionType = motionType;
+    motionEvents[nextIndex].valid = 1;
+
+    // Update counters
+    nextIndex++;
+    if (nextIndex >= MAX_MOTION_EVENTS) {
+        nextIndex = 0;  // Wrap around (circular buffer)
+    }
+
+    if (eventCount < MAX_MOTION_EVENTS) {
+        eventCount++;
+    }
+
+    return 1;
+}
+
+/**
+ * @brief Get the number of logged events
+ * @return Number of events in buffer
+ */
+uint16_t MotionLogger_GetEventCount(void)
+{
+    return eventCount;
+}
+
+/**
+ * @brief Get a specific event by index
+ * @param index Event index (0 = oldest if buffer is full)
+ * @return Pointer to event, or NULL if invalid
+ */
+MotionEvent_t* MotionLogger_GetEvent(uint16_t index)
+{
+    if (index >= eventCount) {
+        return NULL;
+    }
+
+    // Calculate actual index in circular buffer
+    uint16_t actualIndex;
+    if (eventCount < MAX_MOTION_EVENTS) {
+        actualIndex = index;
+    } else {
+        // Buffer is full, calculate from nextIndex
+        actualIndex = (nextIndex + index) % MAX_MOTION_EVENTS;
+    }
+
+    if (motionEvents[actualIndex].valid) {
+        return &motionEvents[actualIndex];
+    }
+
+    return NULL;
+}
+
+/**
+ * @brief Clear all logged events
+ */
+void MotionLogger_Clear(void)
+{
+    for (uint16_t i = 0; i < MAX_MOTION_EVENTS; i++) {
+        motionEvents[i].valid = 0;
+        motionEvents[i].motionType = MOTION_TYPE_NONE;
+    }
+    eventCount = 0;
+    nextIndex = 0;
+}
diff --git a/Core/Src/sound.c b/Core/Src/sound.c
index f276e9b..985ce38 100644
--- a/Core/Src/sound.c
+++ b/Core/Src/sound.c
@@ -52,11 +52,11 @@ void playTone(uint32_t frequency_hz, uint32_t duration_ms) {
 }
 
 void firstBootTone(){
-    playTone(260, 10);
+    playTone(160, 10);
     HAL_Delay(15);
-    playTone(330, 20);
+    playTone(230, 20);
     HAL_Delay(15);
-    playTone(392, 30);
+    playTone(292, 30);
 }
 
 void SOUND_CalmAlarm(){
@@ -64,10 +64,6 @@ void SOUND_CalmAlarm(){
     HAL_Delay(15);
     playTone(349, 20);
     HAL_Delay(15);
-    playTone(415, 20);
-    HAL_Delay(15);
-    playTone(349, 20);
-    HAL_Delay(200);
 }
 
 void SOUND_NormalAlarm(){
diff --git a/Core/Src/state_machine.c b/Core/Src/state_machine.c
index 69759e9..d65e730 100644
--- a/Core/Src/state_machine.c
+++ b/Core/Src/state_machine.c
@@ -4,6 +4,7 @@
 #include "battery.h"
 #include "lockservice_app.h"
 #include "accelerometer.h"
+#include "motion_logger.h"
 
 // Global state variables
 volatile SystemState_t currentState = STATE_CONNECTED_IDLE;
@@ -21,6 +22,7 @@ static uint32_t stateEntryTime = 0;
 #define GET_SENSITIVITY(byte)     (((byte) >> 3) & 0x03)
 #define GET_LIGHTS_BIT(byte)      (((byte) >> 5) & 0x01)
 #define GET_LOGGING_BIT(byte)     (((byte) >> 6) & 0x01)
+#define GET_SILENCE_BIT(byte)     (((byte) >> 7) & 0x01)
 
 // Helper macros to set bits in settings byte
 #define SET_ARMED_BIT(byte, val)       do { if(val) (byte) |= 0x01; else (byte) &= ~0x01; } while(0)
@@ -28,6 +30,7 @@ static uint32_t stateEntryTime = 0;
 #define SET_SENSITIVITY(byte, val)     do { (byte) = ((byte) & ~0x18) | (((val) & 0x03) << 3); } while(0)
 #define SET_LIGHTS_BIT(byte, val)      do { if(val) (byte) |= 0x20; else (byte) &= ~0x20; } while(0)
 #define SET_LOGGING_BIT(byte, val)     do { if(val) (byte) |= 0x40; else (byte) &= ~0x40; } while(0)
+#define SET_SILENCE_BIT(byte, val)     do { if(val) (byte) |= 0x80; else (byte) &= ~0x80; } while(0)
 
 // Alarm type constants (matches iOS AlarmType enum)
 #define ALARM_NONE        0x00
@@ -52,7 +55,8 @@ void StateMachine_Init(void)
     SET_ALARM_TYPE(deviceState, ALARM_CALM); // Bits 1-2: Normal alarm
     SET_SENSITIVITY(deviceState, SENSITIVITY_MEDIUM); // Bits 3-4: Medium sensitivity
     SET_LIGHTS_BIT(deviceState, 1);          // Bit 5: Lights on
-    SET_LOGGING_BIT(deviceState, 0);         // Bit 6: Logging off
+    SET_LOGGING_BIT(deviceState, 1);         // Bit 6: Logging on
+    SET_SILENCE_BIT(deviceState, 1);		 // Bit 7: Silence on
 
     // Initialize deviceInfo (for future use)
     deviceInfo = 0;
@@ -103,6 +107,7 @@ void State_Connected_Idle_Loop(){
     if (GET_ARMED_BIT(deviceState)) {
         // Armed - transition to ARMED state
     	LIS2DUX12_ClearMotion();
+    	//Acceleromter Register Update Function Goes Here
         StateMachine_ChangeState(STATE_LOCKED);
     } else {
         // Not armed - turn off LED if lights are enabled
@@ -119,10 +124,13 @@ void State_Connected_Idle_Loop(){
  * Motion events should be logged in the alarm state
  ***************************************************************************/
 void State_Locked_Loop(){
+    static uint8_t lastMotionState = GPIO_PIN_RESET;  // Track previous state
+
     // Check if iOS sent a disarm command
     if (!GET_ARMED_BIT(deviceState)) {
         // Disarmed - go back to idle
         StateMachine_ChangeState(STATE_CONNECTED_IDLE);
+        lastMotionState = GPIO_PIN_RESET;  // Reset on disarm
         return;
     }
 
@@ -134,18 +142,31 @@ void State_Locked_Loop(){
     }
 
     // Check for motion detection using accelerometer
-    //if (LIS2DUX12_IsMotionDetected()) {
-    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET) {
-        // Log motion event if logging is enabled
+    uint8_t currentMotionState = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0);
+
+    // Detect RISING EDGE (transition from LOW to HIGH)
+    if (currentMotionState == GPIO_PIN_SET && lastMotionState == GPIO_PIN_RESET) {
+
+        // Log motion event if logging is enabled (ONCE per rising edge)
         if (GET_LOGGING_BIT(deviceState)) {
-            // TODO: Log to EEPROM with timestamp
+            MotionLogger_LogEvent(1);  // 1 = MOTION_TYPE_SMALL
+            LOCKSERVICE_SendMotionAlert();  // Send alert ONCE on rising edge
         }
 
-        // Trigger alarm
-        StateMachine_ChangeState(STATE_ALARM_ACTIVE);
-        return;
+        // Trigger alarm (if not silenced)
+        if (!GET_SILENCE_BIT(deviceState)){
+            StateMachine_ChangeState(STATE_ALARM_ACTIVE);
+        } else {
+            // If silenced, just wait for motion to stop
+            while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET) {
+                HAL_Delay(10);
+            }
+        }
     }
 
+    // Update last state
+    lastMotionState = currentMotionState;
+
     // eventually time out and go to sleep after n seconds
 }
 
@@ -238,7 +259,7 @@ void StateMachine_Run(void)
 {
 	static uint8_t previousBattery = 0xFF;  // Initialize to invalid value to force first update
 
-	if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_3) == 0) {
+	if (HAL_GPIO_ReadPin(GPIOB, CHARGE_Pin) == 0) {
 		//Battery_IsCharging();
 	    deviceBattery |= 0b10000000;  // Set bit 7
 	    testLED(50);
diff --git a/Core/Src/stm32wb0x_hal_msp.c b/Core/Src/stm32wb0x_hal_msp.c
index 4165405..b4bdb47 100644
--- a/Core/Src/stm32wb0x_hal_msp.c
+++ b/Core/Src/stm32wb0x_hal_msp.c
@@ -321,6 +321,62 @@ void HAL_RNG_MspDeInit(RNG_HandleTypeDef* hrng)
 
 }
 
+/**
+  * @brief RTC MSP Initialization
+  * This function configures the hardware resources used in this example
+  * @param hrtc: RTC handle pointer
+  * @retval None
+  */
+void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
+{
+  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
+  if(hrtc->Instance==RTC)
+  {
+    /* USER CODE BEGIN RTC_MspInit 0 */
+
+    /* USER CODE END RTC_MspInit 0 */
+
+  /** Initializes the peripherals clock
+  */
+    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC_WDG_BLEWKUP;
+    PeriphClkInitStruct.RTCWDGBLEWKUPClockSelection = RCC_RTC_WDG_BLEWKUP_CLKSOURCE_LSE;
+    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
+    {
+      Error_Handler();
+    }
+
+    /* Peripheral clock enable */
+    __HAL_RCC_RTC_CLK_ENABLE();
+    /* USER CODE BEGIN RTC_MspInit 1 */
+
+    /* USER CODE END RTC_MspInit 1 */
+
+  }
+
+}
+
+/**
+  * @brief RTC MSP De-Initialization
+  * This function freeze the hardware resources used in this example
+  * @param hrtc: RTC handle pointer
+  * @retval None
+  */
+void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
+{
+  if(hrtc->Instance==RTC)
+  {
+    /* USER CODE BEGIN RTC_MspDeInit 0 */
+
+    /* USER CODE END RTC_MspDeInit 0 */
+    /* Peripheral clock disable */
+    __HAL_RCC_RTC_CLK_DISABLE();
+    /* USER CODE BEGIN RTC_MspDeInit 1 */
+
+    /* USER CODE END RTC_MspDeInit 1 */
+  }
+
+}
+
 /**
   * @brief TIM_Base MSP Initialization
   * This function configures the hardware resources used in this example
diff --git a/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_hal_rtc.h b/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_hal_rtc.h
new file mode 100644
index 0000000..02969ee
--- /dev/null
+++ b/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_hal_rtc.h
@@ -0,0 +1,771 @@
+/**
+  ******************************************************************************
+  * @file    stm32wb0x_hal_rtc.h
+  * @author  MCD Application Team
+  * @brief   Header file of RTC HAL module.
+  ******************************************************************************
+  * @attention
+  *
+  * Copyright (c) 2024 STMicroelectronics.
+  * All rights reserved.
+  *
+  * This software is licensed under terms that can be found in the LICENSE file
+  * in the root directory of this software component.
+  * If no LICENSE file comes with this software, it is provided AS-IS.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef STM32WB0x_HAL_RTC_H
+#define STM32WB0x_HAL_RTC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+
+#include "stm32wb0x_hal_def.h"
+
+/** @addtogroup STM32WB0x_HAL_Driver
+  * @{
+  */
+
+/** @addtogroup RTC
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/** @defgroup RTC_Exported_Types RTC Exported Types
+  * @{
+  */
+
+/**
+  * @brief  HAL State structures definition
+  */
+typedef enum
+{
+  HAL_RTC_STATE_RESET             = 0x00U,  /*!< RTC not yet initialized or disabled */
+  HAL_RTC_STATE_READY             = 0x01U,  /*!< RTC initialized and ready for use   */
+  HAL_RTC_STATE_BUSY              = 0x02U,  /*!< RTC process is ongoing              */
+  HAL_RTC_STATE_TIMEOUT           = 0x03U,  /*!< RTC timeout state                   */
+  HAL_RTC_STATE_ERROR             = 0x04U   /*!< RTC error state                     */
+} HAL_RTCStateTypeDef;
+
+/**
+  * @brief  RTC Configuration Structure definition
+  */
+typedef struct
+{
+  uint32_t HourFormat;      /*!< Specifies the RTC Hour Format.
+                                 This parameter can be a value of @ref RTC_Hour_Formats */
+
+  uint32_t AsynchPrediv;    /*!< Specifies the RTC Asynchronous Predivider value.
+                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F */
+
+  uint32_t SynchPrediv;     /*!< Specifies the RTC Synchronous Predivider value.
+                                 This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0x7FFF */
+
+  uint32_t OutPut;          /*!< Specifies which signal will be routed to the RTC output.
+                                 This parameter can be a value of @ref RTC_Output_selection_Definitions */
+
+  uint32_t OutPutPolarity;  /*!< Specifies the polarity of the output signal.
+                                 This parameter can be a value of @ref RTC_Output_Polarity_Definitions */
+} RTC_InitTypeDef;
+
+/**
+  * @brief  RTC Time structure definition
+  */
+typedef struct
+{
+  uint8_t Hours;            /*!< Specifies the RTC Time Hour.
+                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected
+                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected */
+
+  uint8_t Minutes;          /*!< Specifies the RTC Time Minutes.
+                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
+
+  uint8_t Seconds;          /*!< Specifies the RTC Time Seconds.
+                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
+
+  uint8_t TimeFormat;       /*!< Specifies the RTC AM/PM Time.
+                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */
+
+  uint32_t SubSeconds;      /*!< Specifies the RTC_SSR RTC Sub Second register content.
+                                 This parameter corresponds to a time unit range between [0-1] Second
+                                 with [1 Sec / SecondFraction +1] granularity */
+
+  uint32_t SecondFraction;  /*!< Specifies the range or granularity of Sub Second register content
+                                 corresponding to Synchronous prescaler factor value (PREDIV_S)
+                                 This parameter corresponds to a time unit range between [0-1] Second
+                                 with [1 Sec / SecondFraction +1] granularity.
+                                 This field will be used only by HAL_RTC_GetTime function */
+
+  uint32_t DayLightSaving;  /*!< This interface is deprecated. To manage Daylight
+                                 Saving Time, please use HAL_RTC_DST_xxx functions */
+
+  uint32_t StoreOperation;  /*!< This interface is deprecated. To manage Daylight
+                                 Saving Time, please use HAL_RTC_DST_xxx functions */
+} RTC_TimeTypeDef;
+
+/**
+  * @brief  RTC Date structure definition
+  */
+typedef struct
+{
+  uint8_t WeekDay;  /*!< Specifies the RTC Date WeekDay.
+                         This parameter can be a value of @ref RTC_WeekDay_Definitions */
+
+  uint8_t Month;    /*!< Specifies the RTC Date Month (in BCD format).
+                         This parameter can be a value of @ref RTC_Month_Date_Definitions */
+
+  uint8_t Date;     /*!< Specifies the RTC Date.
+                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */
+
+  uint8_t Year;     /*!< Specifies the RTC Date Year.
+                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */
+
+} RTC_DateTypeDef;
+
+/**
+  * @brief  RTC Alarm structure definition
+  */
+typedef struct
+{
+  RTC_TimeTypeDef AlarmTime;     /*!< Specifies the RTC Alarm Time members */
+
+  uint32_t AlarmMask;            /*!< Specifies the RTC Alarm Masks.
+                                      This parameter can be a value of @ref RTC_AlarmMask_Definitions */
+
+  uint32_t AlarmSubSecondMask;   /*!< Specifies the RTC Alarm SubSeconds Masks.
+                                      This parameter can be a value of @ref RTC_Alarm_Sub_Seconds_Masks_Definitions */
+
+  uint32_t AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
+                                      This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
+
+  uint8_t AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
+                                      If the Alarm Date is selected, this parameter must be set to a value in the 1-31 range.
+                                      If the Alarm WeekDay is selected, this parameter can be a value of @ref RTC_WeekDay_Definitions */
+
+  uint32_t Alarm;                /*!< Specifies the alarm .
+                                      This parameter can be a value of @ref RTC_Alarms_Definitions */
+} RTC_AlarmTypeDef;
+
+/**
+  * @brief  RTC Handle Structure definition
+  */
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+typedef struct __RTC_HandleTypeDef
+#else
+typedef struct
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+{
+  RTC_TypeDef                 *Instance;  /*!< Register base address    */
+
+  RTC_InitTypeDef             Init;       /*!< RTC required parameters  */
+
+  HAL_LockTypeDef             Lock;       /*!< RTC locking object       */
+
+  __IO HAL_RTCStateTypeDef    State;      /*!< Time communication state */
+
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+  void (* AlarmAEventCallback)      (struct __RTC_HandleTypeDef *hrtc);  /*!< RTC Alarm A Event callback         */
+
+  void (* WakeUpTimerEventCallback) (struct __RTC_HandleTypeDef *hrtc);  /*!< RTC WakeUpTimer Event callback     */
+
+  void (* MspInitCallback)          (struct __RTC_HandleTypeDef *hrtc);  /*!< RTC Msp Init callback              */
+
+  void (* MspDeInitCallback)        (struct __RTC_HandleTypeDef *hrtc);  /*!< RTC Msp DeInit callback            */
+
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+
+} RTC_HandleTypeDef;
+
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+/**
+  * @brief  HAL RTC Callback ID enumeration definition
+  */
+typedef enum
+{
+  HAL_RTC_ALARM_A_EVENT_CB_ID           = 0x00U,    /*!< RTC Alarm A Event Callback ID       */
+  HAL_RTC_WAKEUPTIMER_EVENT_CB_ID       = 0x03U,    /*!< RTC Wakeup Timer Event Callback ID  */
+  HAL_RTC_MSPINIT_CB_ID                 = 0x0EU,    /*!< RTC Msp Init callback ID            */
+  HAL_RTC_MSPDEINIT_CB_ID               = 0x0FU     /*!< RTC Msp DeInit callback ID          */
+} HAL_RTC_CallbackIDTypeDef;
+
+/**
+  * @brief  HAL RTC Callback pointer definition
+  */
+typedef  void (*pRTC_CallbackTypeDef)(RTC_HandleTypeDef *hrtc);  /*!< pointer to an RTC callback function */
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+
+/**
+  * @}
+  */
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup RTC_Exported_Constants RTC Exported Constants
+  * @{
+  */
+
+/** @defgroup RTC_Hour_Formats RTC Hour Formats
+  * @{
+  */
+#define RTC_HOURFORMAT_24              0x00000000U
+#define RTC_HOURFORMAT_12              RTC_CR_FMT
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Output_selection_Definitions RTC Output Selection Definitions
+  * @{
+  */
+#define RTC_OUTPUT_DISABLE             0x00000000U
+#define RTC_OUTPUT_ALARMA              RTC_CR_OSEL_0
+#define RTC_OUTPUT_WAKEUP              RTC_CR_OSEL
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Output_Polarity_Definitions RTC Output Polarity Definitions
+  * @{
+  */
+#define RTC_OUTPUT_POLARITY_HIGH       0x00000000U
+#define RTC_OUTPUT_POLARITY_LOW        RTC_CR_POL
+/**
+  * @}
+  */
+
+/** @defgroup RTC_AM_PM_Definitions RTC AM PM Definitions
+  * @{
+  */
+#define RTC_HOURFORMAT12_AM            ((uint8_t)0x00)
+#define RTC_HOURFORMAT12_PM            ((uint8_t)0x01)
+/**
+  * @}
+  */
+
+/** @defgroup RTC_DayLightSaving_Definitions RTC DayLight Saving Definitions
+  * @{
+  */
+#define RTC_DAYLIGHTSAVING_SUB1H       RTC_CR_SUB1H
+#define RTC_DAYLIGHTSAVING_ADD1H       RTC_CR_ADD1H
+#define RTC_DAYLIGHTSAVING_NONE        0x00000000U
+/**
+  * @}
+  */
+
+/** @defgroup RTC_StoreOperation_Definitions RTC Store Operation Definitions
+  * @{
+  */
+#define RTC_STOREOPERATION_RESET        0x00000000U
+#define RTC_STOREOPERATION_SET          RTC_CR_BKP
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Input_parameter_format_definitions RTC Input Parameter Format Definitions
+  * @{
+  */
+#define RTC_FORMAT_BIN                  0x00000000U
+#define RTC_FORMAT_BCD                  0x00000001U
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Month_Date_Definitions RTC Month Date Definitions (in BCD format)
+  * @{
+  */
+#define RTC_MONTH_JANUARY              ((uint8_t)0x01)
+#define RTC_MONTH_FEBRUARY             ((uint8_t)0x02)
+#define RTC_MONTH_MARCH                ((uint8_t)0x03)
+#define RTC_MONTH_APRIL                ((uint8_t)0x04)
+#define RTC_MONTH_MAY                  ((uint8_t)0x05)
+#define RTC_MONTH_JUNE                 ((uint8_t)0x06)
+#define RTC_MONTH_JULY                 ((uint8_t)0x07)
+#define RTC_MONTH_AUGUST               ((uint8_t)0x08)
+#define RTC_MONTH_SEPTEMBER            ((uint8_t)0x09)
+#define RTC_MONTH_OCTOBER              ((uint8_t)0x10)
+#define RTC_MONTH_NOVEMBER             ((uint8_t)0x11)
+#define RTC_MONTH_DECEMBER             ((uint8_t)0x12)
+/**
+  * @}
+  */
+
+/** @defgroup RTC_WeekDay_Definitions RTC WeekDay Definitions
+  * @{
+  */
+#define RTC_WEEKDAY_MONDAY             ((uint8_t)0x01)
+#define RTC_WEEKDAY_TUESDAY            ((uint8_t)0x02)
+#define RTC_WEEKDAY_WEDNESDAY          ((uint8_t)0x03)
+#define RTC_WEEKDAY_THURSDAY           ((uint8_t)0x04)
+#define RTC_WEEKDAY_FRIDAY             ((uint8_t)0x05)
+#define RTC_WEEKDAY_SATURDAY           ((uint8_t)0x06)
+#define RTC_WEEKDAY_SUNDAY             ((uint8_t)0x07)
+/**
+  * @}
+  */
+
+/** @defgroup RTC_AlarmDateWeekDay_Definitions RTC Alarm Date WeekDay Definitions
+  * @{
+  */
+#define RTC_ALARMDATEWEEKDAYSEL_DATE      0x00000000U
+#define RTC_ALARMDATEWEEKDAYSEL_WEEKDAY   RTC_ALRMAR_WDSEL
+/**
+  * @}
+  */
+
+/** @defgroup RTC_AlarmMask_Definitions RTC Alarm Mask Definitions
+  * @{
+  */
+#define RTC_ALARMMASK_NONE                0x00000000U
+#define RTC_ALARMMASK_DATEWEEKDAY         RTC_ALRMAR_MSK4
+#define RTC_ALARMMASK_HOURS               RTC_ALRMAR_MSK3
+#define RTC_ALARMMASK_MINUTES             RTC_ALRMAR_MSK2
+#define RTC_ALARMMASK_SECONDS             RTC_ALRMAR_MSK1
+#define RTC_ALARMMASK_ALL                 (RTC_ALARMMASK_DATEWEEKDAY | \
+                                           RTC_ALARMMASK_HOURS       | \
+                                           RTC_ALARMMASK_MINUTES     | \
+                                           RTC_ALARMMASK_SECONDS)
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Alarms_Definitions RTC Alarms Definitions
+  * @{
+  */
+#define RTC_ALARM_A                       RTC_CR_ALRAE
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions RTC Alarm Sub Seconds Masks Definitions
+  * @{
+  */
+/*!< All Alarm SS fields are masked. There is no comparison on sub seconds for Alarm */
+#define RTC_ALARMSUBSECONDMASK_ALL         0x00000000U
+/*!< SS[14:1] are don't care in Alarm comparison. Only SS[0] is compared.     */
+#define RTC_ALARMSUBSECONDMASK_SS14_1      RTC_ALRMASSR_MASKSS_0
+/*!< SS[14:2] are don't care in Alarm comparison. Only SS[1:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_2      RTC_ALRMASSR_MASKSS_1
+/*!< SS[14:3] are don't care in Alarm comparison. Only SS[2:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_3      (RTC_ALRMASSR_MASKSS_0 | RTC_ALRMASSR_MASKSS_1)
+/*!< SS[14:4] are don't care in Alarm comparison. Only SS[3:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_4      RTC_ALRMASSR_MASKSS_2
+/*!< SS[14:5] are don't care in Alarm comparison. Only SS[4:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_5      (RTC_ALRMASSR_MASKSS_0 | RTC_ALRMASSR_MASKSS_2)
+/*!< SS[14:6] are don't care in Alarm comparison. Only SS[5:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_6      (RTC_ALRMASSR_MASKSS_1 | RTC_ALRMASSR_MASKSS_2)
+/*!< SS[14:7] are don't care in Alarm comparison. Only SS[6:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_7      (RTC_ALRMASSR_MASKSS_0 | RTC_ALRMASSR_MASKSS_1 | RTC_ALRMASSR_MASKSS_2)
+/*!< SS[14:8] are don't care in Alarm comparison. Only SS[7:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_8      RTC_ALRMASSR_MASKSS_3
+/*!< SS[14:9] are don't care in Alarm comparison. Only SS[8:0] are compared.  */
+#define RTC_ALARMSUBSECONDMASK_SS14_9      (RTC_ALRMASSR_MASKSS_0 | RTC_ALRMASSR_MASKSS_3)
+/*!< SS[14:10] are don't care in Alarm comparison. Only SS[9:0] are compared. */
+#define RTC_ALARMSUBSECONDMASK_SS14_10     (RTC_ALRMASSR_MASKSS_1 | RTC_ALRMASSR_MASKSS_3)
+/*!< SS[14:11] are don't care in Alarm comparison. Only SS[10:0] are compared. */
+#define RTC_ALARMSUBSECONDMASK_SS14_11     (RTC_ALRMASSR_MASKSS_0 | RTC_ALRMASSR_MASKSS_1 | RTC_ALRMASSR_MASKSS_3)
+/*!< SS[14:12] are don't care in Alarm comparison. Only SS[11:0] are compared. */
+#define RTC_ALARMSUBSECONDMASK_SS14_12     (RTC_ALRMASSR_MASKSS_2 | RTC_ALRMASSR_MASKSS_3)
+/*!< SS[14:13] are don't care in Alarm comparison. Only SS[12:0] are compared. */
+#define RTC_ALARMSUBSECONDMASK_SS14_13     (RTC_ALRMASSR_MASKSS_0 | RTC_ALRMASSR_MASKSS_2 | RTC_ALRMASSR_MASKSS_3)
+/*!< SS[14] is don't care in Alarm comparison. Only SS[13:0] are compared. */
+#define RTC_ALARMSUBSECONDMASK_SS14        (RTC_ALRMASSR_MASKSS_1 | RTC_ALRMASSR_MASKSS_2 | RTC_ALRMASSR_MASKSS_3)
+/*!< SS[14:0] are compared and must match to activate alarm. */
+#define RTC_ALARMSUBSECONDMASK_NONE        RTC_ALRMASSR_MASKSS
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Interrupts_Definitions RTC Interrupts Definitions
+  * @{
+  */
+#define RTC_IT_WUT                        RTC_CR_WUTIE        /*!< Enable Wakeup timer Interrupt            */
+#define RTC_IT_ALRA                       RTC_CR_ALRAIE       /*!< Enable Alarm A Interrupt                 */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Flags_Definitions RTC Flags Definitions
+  * @{
+  */
+#define RTC_FLAG_RECALPF                  RTC_ISR_RECALPF     /*!< Recalibration pending flag               */
+#define RTC_FLAG_WUTF                     RTC_ISR_WUTF        /*!< Wakeup timer event flag                  */
+#define RTC_FLAG_ALRAF                    RTC_ISR_ALRAF       /*!< Alarm A event flag                       */
+#define RTC_FLAG_INITF                    RTC_ISR_INITF       /*!< RTC in initialization mode flag          */
+#define RTC_FLAG_RSF                      RTC_ISR_RSF         /*!< Register synchronization flag            */
+#define RTC_FLAG_INITS                    RTC_ISR_INITS       /*!< RTC initialization status flag           */
+#define RTC_FLAG_SHPF                     RTC_ISR_SHPF        /*!< Shift operation pending flag             */
+#define RTC_FLAG_WUTWF                    RTC_ISR_WUTWF       /*!< WUTR register write allowance flag       */
+#define RTC_FLAG_ALRAWF                   RTC_ISR_ALRAWF      /*!< ALRMAR register write allowance flag     */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macros -----------------------------------------------------------*/
+
+/** @defgroup RTC_Exported_Macros RTC Exported Macros
+  * @{
+  */
+
+/** @brief Reset RTC handle state
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) do {                                            \
+                                                      (__HANDLE__)->State = HAL_RTC_STATE_RESET; \
+                                                      (__HANDLE__)->MspInitCallback = NULL;      \
+                                                      (__HANDLE__)->MspDeInitCallback = NULL;    \
+                                                    } while(0U)
+#else
+#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RTC_STATE_RESET)
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+
+/**
+  * @brief  Disable the write protection for RTC registers.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__) do {                                       \
+                                                           (__HANDLE__)->Instance->WPR = 0xCAU;  \
+                                                           (__HANDLE__)->Instance->WPR = 0x53U;  \
+                                                         } while(0U)
+
+/**
+  * @brief  Enable the write protection for RTC registers.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__) do {                                       \
+                                                          (__HANDLE__)->Instance->WPR = 0xFFU;  \
+                                                        } while(0U)
+
+/**
+  * @brief  Check whether the RTC Calendar is initialized.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_IS_CALENDAR_INITIALIZED(__HANDLE__)                 (((((__HANDLE__)->Instance->ISR) & (RTC_FLAG_INITS)) == RTC_FLAG_INITS) ? 1U : 0U)
+
+/**
+  * @brief  Enable the RTC ALARMA peripheral.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_ALARMA_ENABLE(__HANDLE__)                           ((__HANDLE__)->Instance->CR |= (RTC_CR_ALRAE))
+
+/**
+  * @brief  Disable the RTC ALARMA peripheral.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_ALARMA_DISABLE(__HANDLE__)                          ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ALRAE))
+
+/**
+  * @brief  Enable the RTC Alarm interrupt.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to be enabled or disabled.
+  *          This parameter can be:
+  *             @arg RTC_IT_ALRA: Alarm A interrupt
+  * @retval None
+  */
+#define __HAL_RTC_ALARM_ENABLE_IT(__HANDLE__, __INTERRUPT__)          ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
+
+/**
+  * @brief  Disable the RTC Alarm interrupt.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to be enabled or disabled.
+  *          This parameter can be:
+  *             @arg RTC_IT_ALRA: Alarm A interrupt
+  * @retval None
+  */
+#define __HAL_RTC_ALARM_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
+
+/**
+  * @brief  Check whether the specified RTC Alarm interrupt has occurred or not.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt to check.
+  *         This parameter can be:
+  *            @arg RTC_IT_ALRA: Alarm A interrupt
+  * @retval None
+  */
+#define __HAL_RTC_ALARM_GET_IT(__HANDLE__, __INTERRUPT__)           (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__) >> 4U)) != 0U) ? 1U : 0U)
+
+/**
+  * @brief  Get the selected RTC Alarm's flag status.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __FLAG__ specifies the RTC Alarm Flag to check.
+  *         This parameter can be:
+  *            @arg RTC_FLAG_ALRAF: Alarm A interrupt flag
+  *            @arg RTC_FLAG_ALRAWF: Alarm A 'write allowed' flag
+  * @retval None
+  */
+#define __HAL_RTC_ALARM_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != 0U) ? 1U : 0U)
+
+/**
+  * @brief  Clear the RTC Alarm's pending flags.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __FLAG__ specifies the RTC Alarm flag to be cleared.
+  *          This parameter can be:
+  *             @arg RTC_FLAG_ALRAF
+  * @retval None
+  */
+#define __HAL_RTC_ALARM_CLEAR_FLAG(__HANDLE__, __FLAG__)                  ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
+
+/**
+  * @brief  Check whether the specified RTC Alarm interrupt has been enabled or not.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to check.
+  *         This parameter can be:
+  *            @arg RTC_IT_ALRA: Alarm A interrupt
+  * @retval None
+  */
+#define __HAL_RTC_ALARM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != 0U) ? 1U : 0U)
+
+/**
+  * @}
+  */
+
+/* Include RTC HAL Extended module */
+#include "stm32wb0x_hal_rtc_ex.h"
+
+/* Exported functions --------------------------------------------------------*/
+
+/** @addtogroup RTC_Exported_Functions
+  * @{
+  */
+
+/** @addtogroup RTC_Exported_Functions_Group1
+  * @{
+  */
+/* Initialization and de-initialization functions  ****************************/
+HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc);
+void              HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc);
+void              HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc);
+
+/* Callbacks Register/UnRegister functions  ***********************************/
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+HAL_StatusTypeDef HAL_RTC_RegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID, pRTC_CallbackTypeDef pCallback);
+HAL_StatusTypeDef HAL_RTC_UnRegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID);
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+/**
+  * @}
+  */
+
+/** @addtogroup RTC_Exported_Functions_Group2
+  * @{
+  */
+/* RTC Time and Date functions ************************************************/
+HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
+HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
+HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
+HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
+/**
+  * @}
+  */
+
+/** @addtogroup RTC_Exported_Functions_Group3
+  * @{
+  */
+/* RTC Alarm functions ********************************************************/
+HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
+HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
+HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm);
+HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format);
+void              HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
+void              HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc);
+/**
+  * @}
+  */
+
+/** @addtogroup RTC_Exported_Functions_Group4
+  * @{
+  */
+/* Peripheral Control functions ***********************************************/
+HAL_StatusTypeDef   HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc);
+
+/* RTC Daylight Saving Time functions *****************************************/
+void              HAL_RTC_DST_Add1Hour(RTC_HandleTypeDef *hrtc);
+void              HAL_RTC_DST_Sub1Hour(RTC_HandleTypeDef *hrtc);
+void              HAL_RTC_DST_SetStoreOperation(RTC_HandleTypeDef *hrtc);
+void              HAL_RTC_DST_ClearStoreOperation(RTC_HandleTypeDef *hrtc);
+uint32_t          HAL_RTC_DST_ReadStoreOperation(RTC_HandleTypeDef *hrtc);
+/**
+  * @}
+  */
+
+/** @addtogroup RTC_Exported_Functions_Group5
+  * @{
+  */
+/* Peripheral State functions *************************************************/
+HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc);
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Private types -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private constants ---------------------------------------------------------*/
+
+/** @defgroup RTC_Private_Constants RTC Private Constants
+  * @{
+  */
+/* Masks Definition */
+#define RTC_TR_RESERVED_MASK    ((uint32_t)(RTC_TR_HT  | RTC_TR_HU  | \
+                                            RTC_TR_MNT | RTC_TR_MNU | \
+                                            RTC_TR_ST  | RTC_TR_SU  | \
+                                            RTC_TR_PM))
+#define RTC_DR_RESERVED_MASK    ((uint32_t)(RTC_DR_YT | RTC_DR_YU | \
+                                            RTC_DR_MT | RTC_DR_MU | \
+                                            RTC_DR_DT | RTC_DR_DU | \
+                                            RTC_DR_WDU))
+#define RTC_ISR_RESERVED_MASK   ((uint32_t)(RTC_FLAGS_MASK | RTC_ISR_INIT))
+#define RTC_INIT_MASK           0xFFFFFFFFU
+#define RTC_RSF_MASK            ((uint32_t)~(RTC_ISR_INIT | RTC_ISR_RSF))
+#define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_INITF   | RTC_FLAG_INITS  | \
+                                            RTC_FLAG_ALRAF   | RTC_FLAG_ALRAWF | \
+                                            RTC_FLAG_WUTF    | RTC_FLAG_WUTWF  | \
+                                            RTC_FLAG_RECALPF | RTC_FLAG_SHPF   | \
+                                            RTC_FLAG_RSF))
+
+#define RTC_TIMEOUT_VALUE       1000U
+
+/**
+  * @}
+  */
+
+/* Private macros ------------------------------------------------------------*/
+
+/** @defgroup RTC_Private_Macros RTC Private Macros
+  * @{
+  */
+
+/** @defgroup RTC_IS_RTC_Definitions RTC Private macros to check input parameters
+  * @{
+  */
+#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HOURFORMAT_12) || \
+                                        ((FORMAT) == RTC_HOURFORMAT_24))
+
+#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) || \
+                               ((OUTPUT) == RTC_OUTPUT_ALARMA)  || \
+                               ((OUTPUT) == RTC_OUTPUT_WAKEUP))
+
+#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OUTPUT_POLARITY_HIGH) || \
+                                ((POL) == RTC_OUTPUT_POLARITY_LOW))
+
+#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7FU)
+#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFFU)
+
+#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0U) && ((HOUR) <= 12U))
+#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23U)
+#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59U)
+#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59U)
+
+#define IS_RTC_HOURFORMAT12(PM)  (((PM) == RTC_HOURFORMAT12_AM) || \
+                                  ((PM) == RTC_HOURFORMAT12_PM))
+
+#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DAYLIGHTSAVING_SUB1H) || \
+                                      ((SAVE) == RTC_DAYLIGHTSAVING_ADD1H) || \
+                                      ((SAVE) == RTC_DAYLIGHTSAVING_NONE))
+
+#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_STOREOPERATION_RESET) || \
+                                           ((OPERATION) == RTC_STOREOPERATION_SET))
+
+#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_FORMAT_BIN) || ((FORMAT) == RTC_FORMAT_BCD))
+
+#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99U)
+#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1U) && ((MONTH) <= 12U))
+#define IS_RTC_DATE(DATE)              (((DATE) >= 1U) && ((DATE) <= 31U))
+
+#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    || \
+                                 ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   || \
+                                 ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) || \
+                                 ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  || \
+                                 ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    || \
+                                 ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  || \
+                                 ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
+
+#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0U) && ((DATE) <= 31U))
+
+#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    || \
+                                                    ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   || \
+                                                    ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) || \
+                                                    ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  || \
+                                                    ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    || \
+                                                    ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  || \
+                                                    ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
+
+#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_ALARMDATEWEEKDAYSEL_DATE) || \
+                                            ((SEL) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
+
+#define IS_RTC_ALARM_MASK(MASK)  (((MASK) & ((uint32_t)~RTC_ALARMMASK_ALL)) == 0U)
+
+#define IS_RTC_ALARM(ALARM)      ((ALARM) == RTC_ALARM_A)
+
+#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= RTC_ALRMASSR_SS)
+
+#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_ALARMSUBSECONDMASK_ALL)     || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_1)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_2)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_3)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_4)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_5)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_6)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_7)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_8)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_9)  || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_10) || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_11) || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_12) || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_13) || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14)    || \
+                                              ((MASK) == RTC_ALARMSUBSECONDMASK_NONE))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Private functions ---------------------------------------------------------*/
+
+/** @defgroup RTC_Private_Functions RTC Private Functions
+  * @{
+  */
+HAL_StatusTypeDef  RTC_EnterInitMode(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef  RTC_ExitInitMode(RTC_HandleTypeDef *hrtc);
+uint8_t            RTC_ByteToBcd2(uint8_t number);
+uint8_t            RTC_Bcd2ToByte(uint8_t number);
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* STM32WB0x_HAL_RTC_H */
diff --git a/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_hal_rtc_ex.h b/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_hal_rtc_ex.h
new file mode 100644
index 0000000..5f82c6c
--- /dev/null
+++ b/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_hal_rtc_ex.h
@@ -0,0 +1,348 @@
+/**
+  ******************************************************************************
+  * @file    stm32wb0x_hal_rtc_ex.h
+  * @author  MCD Application Team
+  * @brief   Header file of RTC HAL Extended module.
+  ******************************************************************************
+  * @attention
+  *
+  * Copyright (c) 2024 STMicroelectronics.
+  * All rights reserved.
+  *
+  * This software is licensed under terms that can be found in the LICENSE file
+  * in the root directory of this software component.
+  * If no LICENSE file comes with this software, it is provided AS-IS.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef STM32WB0x_HAL_RTC_EX_H
+#define STM32WB0x_HAL_RTC_EX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+
+#include "stm32wb0x_hal_def.h"
+
+/** @addtogroup STM32WB0x_HAL_Driver
+  * @{
+  */
+
+/** @addtogroup RTCEx
+  * @{
+  */
+
+/* Exported types ------------------------------------------------------------*/
+
+/* Exported constants --------------------------------------------------------*/
+
+/** @defgroup RTCEx_Exported_Constants RTCEx Exported Constants
+  * @{
+  */
+
+/** @defgroup RTCEx_Backup_Registers_Definitions RTCEx Backup Registers Definitions
+  * @{
+  */
+#define RTC_BKP_DR0                       0x00000000U
+#define RTC_BKP_DR1                       0x00000001U
+/**
+  * @}
+  */
+
+/** @defgroup RTCEx_Wakeup_Timer_Definitions RTCEx Wakeup Timer Definitions
+  * @{
+  */
+#define RTC_WAKEUPCLOCK_RTCCLK_DIV16        0x00000000U
+#define RTC_WAKEUPCLOCK_RTCCLK_DIV8         RTC_CR_WUCKSEL_0
+#define RTC_WAKEUPCLOCK_RTCCLK_DIV4         RTC_CR_WUCKSEL_1
+#define RTC_WAKEUPCLOCK_RTCCLK_DIV2         (RTC_CR_WUCKSEL_0 | RTC_CR_WUCKSEL_1)
+#define RTC_WAKEUPCLOCK_CK_SPRE_16BITS      RTC_CR_WUCKSEL_2
+#define RTC_WAKEUPCLOCK_CK_SPRE_17BITS      (RTC_CR_WUCKSEL_1 | RTC_CR_WUCKSEL_2)
+/**
+  * @}
+  */
+
+/** @defgroup RTCEx_Smooth_calib_period_Definitions RTCEx Smooth Calib Period Definitions
+  * @{
+  */
+#define RTC_SMOOTHCALIB_PERIOD_32SEC   0x00000000U      /*!< If RTCCLK = 32768 Hz, smooth calibration
+                                                              period is 32s, otherwise 2^20 RTCCLK pulses */
+#define RTC_SMOOTHCALIB_PERIOD_16SEC   RTC_CALR_CALW16  /*!< If RTCCLK = 32768 Hz, smooth calibration
+                                                              period is 16s, otherwise 2^19 RTCCLK pulses */
+#define RTC_SMOOTHCALIB_PERIOD_8SEC    RTC_CALR_CALW8   /*!< If RTCCLK = 32768 Hz, smooth calibration
+                                                              period is 8s, otherwise 2^18 RTCCLK pulses  */
+/**
+  * @}
+  */
+
+/** @defgroup RTCEx_Smooth_calib_Plus_pulses_Definitions RTCEx Smooth Calib Plus Pulses Definitions
+  * @{
+  */
+#define RTC_SMOOTHCALIB_PLUSPULSES_SET    RTC_CALR_CALP           /*!< The number of RTCCLK pulses added
+                                                                        during a X -second window = Y - CALM[8:0]
+                                                                        with Y = 512, 256, 128 when X = 32, 16, 8 */
+#define RTC_SMOOTHCALIB_PLUSPULSES_RESET  0x00000000U             /*!< The number of RTCCLK pulses subbstited
+                                                                        during a 32-second window = CALM[8:0] */
+/**
+  * @}
+  */
+
+/** @defgroup RTCEx_Add_1_Second_Parameter_Definitions RTCEx Add 1 Second Parameter Definitions
+  * @{
+  */
+#define RTC_SHIFTADD1S_RESET      0x00000000U
+#define RTC_SHIFTADD1S_SET        RTC_SHIFTR_ADD1S
+/**
+  * @}
+  */
+
+/** @defgroup RTCEx_Calib_Output_selection_Definitions RTCEx Calib Output Selection Definitions
+  * @{
+  */
+#define RTC_CALIBOUTPUT_512HZ            0x00000000U
+#define RTC_CALIBOUTPUT_1HZ              RTC_CR_COSEL
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macros -----------------------------------------------------------*/
+
+/** @defgroup RTCEx_Exported_Macros RTCEx Exported Macros
+  * @{
+  */
+
+/* ---------------------------------WAKEUPTIMER-------------------------------*/
+
+/** @defgroup RTCEx_WakeUp_Timer RTCEx WakeUp Timer
+  * @{
+  */
+
+/**
+  * @brief  Enable the RTC WakeUp Timer peripheral.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_ENABLE(__HANDLE__)                      ((__HANDLE__)->Instance->CR |= (RTC_CR_WUTE))
+
+/**
+  * @brief  Disable the RTC Wakeup Timer peripheral.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_DISABLE(__HANDLE__)                     ((__HANDLE__)->Instance->CR &= ~(RTC_CR_WUTE))
+
+/**
+  * @brief  Enable the RTC Wakeup Timer interrupt.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Wakeup Timer interrupt sources to be enabled or disabled.
+  *         This parameter can be:
+  *            @arg RTC_IT_WUT: Wakeup Timer interrupt
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_ENABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
+
+/**
+  * @brief  Disable the RTC Wakeup Timer interrupt.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Wakeup Timer interrupt sources to be enabled or disabled.
+  *         This parameter can be:
+  *            @arg RTC_IT_WUT: Wakeup Timer interrupt
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
+
+/**
+  * @brief  Check whether the specified RTC Wakeup Timer interrupt has occurred or not.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Wakeup Timer interrupt to check.
+  *         This parameter can be:
+  *            @arg RTC_IT_WUT: Wakeup Timer interrupt
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_GET_IT(__HANDLE__, __INTERRUPT__)          (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__) >> 4U)) != 0U) ? 1U : 0U)
+
+/**
+  * @brief  Check whether the specified RTC Wakeup timer interrupt has been enabled or not.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __INTERRUPT__ specifies the RTC Wakeup timer interrupt sources to check.
+  *         This parameter can be:
+  *            @arg RTC_IT_WUT: WakeUpTimer interrupt
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != 0U) ? 1U : 0U)
+
+/**
+  * @brief  Get the selected RTC Wakeup Timer's flag status.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __FLAG__ specifies the RTC Wakeup Timer flag to check.
+  *          This parameter can be:
+  *             @arg RTC_FLAG_WUTF: Wakeup Timer interrupt flag
+  *             @arg RTC_FLAG_WUTWF: Wakeup Timer 'write allowed' flag
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_GET_FLAG(__HANDLE__, __FLAG__)          (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != 0U)? 1U : 0U)
+
+/**
+  * @brief  Clear the RTC Wakeup timer's pending flags.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __FLAG__ specifies the RTC Wakeup Timer Flag to clear.
+  *         This parameter can be:
+  *             @arg RTC_FLAG_WUTF: Wakeup Timer interrupt Flag
+  * @retval None
+  */
+#define __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(__HANDLE__, __FLAG__)            ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
+
+/**
+  * @}
+  */
+
+
+/* ------------------------------CALIBRATION----------------------------------*/
+
+/** @defgroup RTCEx_Calibration RTCEx Calibration
+  * @{
+  */
+
+/**
+  * @brief  Enable the RTC calibration output.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR |= (RTC_CR_COE))
+
+/**
+  * @brief  Disable the calibration output.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @retval None
+  */
+#define __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR &= ~(RTC_CR_COE))
+
+/**
+  * @brief  Get the selected RTC shift operation's flag status.
+  * @param  __HANDLE__ specifies the RTC handle.
+  * @param  __FLAG__ specifies the RTC shift operation Flag is pending or not.
+  *          This parameter can be:
+  *             @arg RTC_FLAG_SHPF: Shift pending flag
+  * @retval None
+  */
+#define __HAL_RTC_SHIFT_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != 0U)? 1U : 0U)
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported functions --------------------------------------------------------*/
+
+/** @defgroup RTCEx_Exported_Functions RTCEx Exported Functions
+  * @{
+  */
+
+/** @addtogroup RTCEx_Exported_Functions_Group2
+  * @{
+  */
+/* RTC Wakeup functions ******************************************************/
+HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
+HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
+HAL_StatusTypeDef HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc);
+uint32_t          HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc);
+void              HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc);
+void              HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
+/**
+  * @}
+  */
+
+/** @addtogroup RTCEx_Exported_Functions_Group3
+  * @{
+  */
+/* Extended Control functions ************************************************/
+void              HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data);
+uint32_t          HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister);
+
+HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue);
+HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS);
+HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput);
+HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc);
+HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc);
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Private types -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private constants ---------------------------------------------------------*/
+/* Private macros ------------------------------------------------------------*/
+
+/** @defgroup RTCEx_Private_Macros RTCEx Private Macros
+  * @{
+  */
+
+/** @defgroup RTCEx_IS_RTC_Definitions Private macros to check input parameters
+  * @{
+  */
+#define IS_RTC_BKP(BKP)     ((BKP) < (uint32_t) RTC_BKP_NUMBER)
+
+#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)   || \
+                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    || \
+                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    || \
+                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    || \
+                                    ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) || \
+                                    ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
+
+#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= RTC_WUTR_WUT)
+
+#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SMOOTHCALIB_PERIOD_32SEC) || \
+                                            ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_16SEC) || \
+                                            ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_8SEC))
+
+#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_SET) || \
+                                        ((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
+
+#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= RTC_CALR_CALM)
+
+#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_SHIFTADD1S_RESET) || \
+                                 ((SEL) == RTC_SHIFTADD1S_SET))
+
+#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= RTC_SHIFTR_SUBFS)
+
+#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CALIBOUTPUT_512HZ) || \
+                                      ((OUTPUT) == RTC_CALIBOUTPUT_1HZ))
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* STM32WB0x_HAL_RTC_EX_H */
diff --git a/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_ll_rtc.h b/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_ll_rtc.h
new file mode 100644
index 0000000..22ff517
--- /dev/null
+++ b/Drivers/STM32WB0x_HAL_Driver/Inc/stm32wb0x_ll_rtc.h
@@ -0,0 +1,2234 @@
+/**
+  ******************************************************************************
+  * @file    stm32wb0x_ll_rtc.h
+  * @author  MCD Application Team
+  * @brief   Header file of RTC LL module.
+  ******************************************************************************
+  * @attention
+  *
+  * Copyright (c) 2024 STMicroelectronics.
+  * All rights reserved.
+  *
+  * This software is licensed under terms that can be found in the LICENSE file
+  * in the root directory of this software component.
+  * If no LICENSE file comes with this software, it is provided AS-IS.
+  *
+  ******************************************************************************
+  */
+
+/* Define to prevent recursive inclusion -------------------------------------*/
+#ifndef STM32WB0x_LL_RTC_H
+#define STM32WB0x_LL_RTC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32wb0x.h"
+
+/** @addtogroup STM32WB0x_LL_Driver
+  * @{
+  */
+
+#if defined(RTC)
+
+/** @defgroup RTC_LL RTC
+  * @{
+  */
+
+/* Private types -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private constants ---------------------------------------------------------*/
+/** @defgroup RTC_LL_Private_Constants RTC Private Constants
+  * @{
+  */
+/* Masks Definition */
+#define RTC_INIT_MASK                 0xFFFFFFFFU
+#define RTC_RSF_MASK                  ((uint32_t)~(RTC_ISR_INIT | RTC_ISR_RSF))
+
+/* Write protection defines */
+#define RTC_WRITE_PROTECTION_DISABLE  ((uint8_t)0xFFU)
+#define RTC_WRITE_PROTECTION_ENABLE_1 ((uint8_t)0xCAU)
+#define RTC_WRITE_PROTECTION_ENABLE_2 ((uint8_t)0x53U)
+
+/* Defines used to combine date & time */
+#define RTC_OFFSET_WEEKDAY            24U
+#define RTC_OFFSET_DAY                16U
+#define RTC_OFFSET_MONTH              8U
+#define RTC_OFFSET_HOUR               16U
+#define RTC_OFFSET_MINUTE             8U
+
+/**
+  * @}
+  */
+
+/* Private macros ------------------------------------------------------------*/
+#if defined(USE_FULL_LL_DRIVER)
+/** @defgroup RTC_LL_Private_Macros RTC Private Macros
+  * @{
+  */
+/**
+  * @}
+  */
+#endif /*USE_FULL_LL_DRIVER*/
+
+/* Exported types ------------------------------------------------------------*/
+#if defined(USE_FULL_LL_DRIVER)
+/** @defgroup RTC_LL_ES_INIT RTC Exported Init structure
+  * @{
+  */
+
+/**
+  * @brief  RTC Init structures definition
+  */
+typedef struct
+{
+  uint32_t HourFormat;   /*!< Specifies the RTC Hours Format.
+                              This parameter can be a value of @ref RTC_LL_EC_HOURFORMAT
+
+                              This feature can be modified afterwards using unitary function
+                              @ref LL_RTC_SetHourFormat(). */
+
+  uint32_t AsynchPrescaler; /*!< Specifies the RTC Asynchronous Predivider value.
+                              This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F
+
+                              This feature can be modified afterwards using unitary function
+                              @ref LL_RTC_SetAsynchPrescaler(). */
+
+  uint32_t SynchPrescaler;  /*!< Specifies the RTC Synchronous Predivider value.
+                              This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF
+
+                              This feature can be modified afterwards using unitary function
+                              @ref LL_RTC_SetSynchPrescaler(). */
+} LL_RTC_InitTypeDef;
+
+/**
+  * @brief  RTC Time structure definition
+  */
+typedef struct
+{
+  uint32_t TimeFormat; /*!< Specifies the RTC AM/PM Time.
+                            This parameter can be a value of @ref RTC_LL_EC_TIME_FORMAT
+
+                            This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetFormat(). */
+
+  uint8_t Hours;       /*!< Specifies the RTC Time Hours.
+                            This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the @ref LL_RTC_TIME_FORMAT_PM is selected.
+                            This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the @ref LL_RTC_TIME_FORMAT_AM_OR_24 is selected.
+
+                            This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetHour(). */
+
+  uint8_t Minutes;     /*!< Specifies the RTC Time Minutes.
+                            This parameter must be a number between Min_Data = 0 and Max_Data = 59
+
+                            This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetMinute(). */
+
+  uint8_t Seconds;     /*!< Specifies the RTC Time Seconds.
+                            This parameter must be a number between Min_Data = 0 and Max_Data = 59
+
+                            This feature can be modified afterwards using unitary function @ref LL_RTC_TIME_SetSecond(). */
+} LL_RTC_TimeTypeDef;
+
+/**
+  * @brief  RTC Date structure definition
+  */
+typedef struct
+{
+  uint8_t WeekDay;  /*!< Specifies the RTC Date WeekDay.
+                         This parameter can be a value of @ref RTC_LL_EC_WEEKDAY
+
+                         This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetWeekDay(). */
+
+  uint8_t Month;    /*!< Specifies the RTC Date Month.
+                         This parameter can be a value of @ref RTC_LL_EC_MONTH
+
+                         This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetMonth(). */
+
+  uint8_t Day;      /*!< Specifies the RTC Date Day.
+                         This parameter must be a number between Min_Data = 1 and Max_Data = 31
+
+                         This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetDay(). */
+
+  uint8_t Year;     /*!< Specifies the RTC Date Year.
+                         This parameter must be a number between Min_Data = 0 and Max_Data = 99
+
+                         This feature can be modified afterwards using unitary function @ref LL_RTC_DATE_SetYear(). */
+} LL_RTC_DateTypeDef;
+
+/**
+  * @brief  RTC Alarm structure definition
+  */
+typedef struct
+{
+  LL_RTC_TimeTypeDef AlarmTime;  /*!< Specifies the RTC Alarm Time members. */
+
+  uint32_t AlarmMask;            /*!< Specifies the RTC Alarm Masks.
+                                      This parameter can be a value of @ref RTC_LL_EC_ALMA_MASK for ALARM A.
+
+                                      This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetMask().
+                                 */
+
+  uint32_t AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on day or WeekDay.
+                                      This parameter can be a value of @ref RTC_LL_EC_ALMA_WEEKDAY_SELECTION for ALARM A.
+
+                                      This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_EnableWeekday() or @ref LL_RTC_ALMA_DisableWeekday().
+                                 */
+
+  uint8_t AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Day/WeekDay.
+                                      If AlarmDateWeekDaySel set to day, this parameter  must be a number between Min_Data = 1 and Max_Data = 31.
+
+                                      This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetDay().
+
+                                      If AlarmDateWeekDaySel set to Weekday, this parameter can be a value of @ref RTC_LL_EC_WEEKDAY.
+
+                                      This feature can be modified afterwards using unitary function @ref LL_RTC_ALMA_SetWeekDay().
+                                 */
+} LL_RTC_AlarmTypeDef;
+
+/**
+  * @}
+  */
+#endif /* USE_FULL_LL_DRIVER */
+
+/* Exported constants --------------------------------------------------------*/
+/** @defgroup RTC_LL_Exported_Constants RTC Exported Constants
+  * @{
+  */
+
+#if defined(USE_FULL_LL_DRIVER)
+/** @defgroup RTC_LL_EC_FORMAT FORMAT
+  * @{
+  */
+#define LL_RTC_FORMAT_BIN                  0x00000000U /*!< Binary data format */
+#define LL_RTC_FORMAT_BCD                  0x00000001U /*!< BCD data format */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_ALMA_WEEKDAY_SELECTION RTC Alarm A Date WeekDay
+  * @{
+  */
+#define LL_RTC_ALMA_DATEWEEKDAYSEL_DATE    0x00000000U             /*!< Alarm A Date is selected */
+#define LL_RTC_ALMA_DATEWEEKDAYSEL_WEEKDAY RTC_ALRMAR_WDSEL        /*!< Alarm A WeekDay is selected */
+/**
+  * @}
+  */
+
+#endif /* USE_FULL_LL_DRIVER */
+
+/** @defgroup RTC_LL_EC_GET_FLAG Get Flags Defines
+  * @brief    Flags defines which can be used with LL_RTC_ReadReg function
+  * @{
+  */
+#define LL_RTC_ISR_RECALPF                 RTC_ISR_RECALPF
+#define LL_RTC_ISR_TSOVF                   RTC_ISR_TSOVF
+#define LL_RTC_ISR_TSF                     RTC_ISR_TSF
+#define LL_RTC_ISR_WUTF                    RTC_ISR_WUTF
+#define LL_RTC_ISR_ALRAF                   RTC_ISR_ALRAF
+#define LL_RTC_ISR_INITF                   RTC_ISR_INITF
+#define LL_RTC_ISR_RSF                     RTC_ISR_RSF
+#define LL_RTC_ISR_INITS                   RTC_ISR_INITS
+#define LL_RTC_ISR_SHPF                    RTC_ISR_SHPF
+#define LL_RTC_ISR_WUTWF                   RTC_ISR_WUTWF
+#define LL_RTC_ISR_ALRAWF                  RTC_ISR_ALRAWF
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_IT IT Defines
+  * @brief    IT defines which can be used with LL_RTC_ReadReg and  LL_RTC_WriteReg functions
+  * @{
+  */
+#define LL_RTC_CR_TSIE                     RTC_CR_TSIE
+#define LL_RTC_CR_WUTIE                    RTC_CR_WUTIE
+#define LL_RTC_CR_ALRAIE                   RTC_CR_ALRAIE
+#define LL_RTC__TAMPIE               RTC__TAMPIE
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_WEEKDAY  WEEK DAY
+  * @{
+  */
+#define LL_RTC_WEEKDAY_MONDAY              ((uint8_t)0x01U) /*!< Monday    */
+#define LL_RTC_WEEKDAY_TUESDAY             ((uint8_t)0x02U) /*!< Tuesday   */
+#define LL_RTC_WEEKDAY_WEDNESDAY           ((uint8_t)0x03U) /*!< Wednesday */
+#define LL_RTC_WEEKDAY_THURSDAY            ((uint8_t)0x04U) /*!< Thrusday  */
+#define LL_RTC_WEEKDAY_FRIDAY              ((uint8_t)0x05U) /*!< Friday    */
+#define LL_RTC_WEEKDAY_SATURDAY            ((uint8_t)0x06U) /*!< Saturday  */
+#define LL_RTC_WEEKDAY_SUNDAY              ((uint8_t)0x07U) /*!< Sunday    */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_MONTH  MONTH
+  * @{
+  */
+#define LL_RTC_MONTH_JANUARY               ((uint8_t)0x01U)  /*!< January   */
+#define LL_RTC_MONTH_FEBRUARY              ((uint8_t)0x02U)  /*!< February  */
+#define LL_RTC_MONTH_MARCH                 ((uint8_t)0x03U)  /*!< March     */
+#define LL_RTC_MONTH_APRIL                 ((uint8_t)0x04U)  /*!< April     */
+#define LL_RTC_MONTH_MAY                   ((uint8_t)0x05U)  /*!< May       */
+#define LL_RTC_MONTH_JUNE                  ((uint8_t)0x06U)  /*!< June      */
+#define LL_RTC_MONTH_JULY                  ((uint8_t)0x07U)  /*!< July      */
+#define LL_RTC_MONTH_AUGUST                ((uint8_t)0x08U)  /*!< August    */
+#define LL_RTC_MONTH_SEPTEMBER             ((uint8_t)0x09U)  /*!< September */
+#define LL_RTC_MONTH_OCTOBER               ((uint8_t)0x10U)  /*!< October   */
+#define LL_RTC_MONTH_NOVEMBER              ((uint8_t)0x11U)  /*!< November  */
+#define LL_RTC_MONTH_DECEMBER              ((uint8_t)0x12U)  /*!< December  */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_HOURFORMAT  HOUR FORMAT
+  * @{
+  */
+#define LL_RTC_HOURFORMAT_24HOUR           0x00000000U           /*!< 24 hour/day format */
+#define LL_RTC_HOURFORMAT_AMPM             RTC_CR_FMT            /*!< AM/PM hour format */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_ALARMOUT  ALARM OUTPUT
+  * @{
+  */
+#define LL_RTC_ALARMOUT_DISABLE            0x00000000U             /*!< Output disabled */
+#define LL_RTC_ALARMOUT_ALMA               RTC_CR_OSEL_0           /*!< Alarm A output enabled */
+#define LL_RTC_ALARMOUT_ALMB               RTC_CR_OSEL_1           /*!< Alarm B output enabled */
+#define LL_RTC_ALARMOUT_WAKEUP             RTC_CR_OSEL             /*!< Wakeup output enabled */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_ALARM_OUTPUTTYPE  ALARM OUTPUT TYPE
+  * @{
+  */
+#define LL_RTC_ALARM_OUTPUTTYPE_OPENDRAIN  0x00000000U                          /*!< RTC_ALARM, when mapped on PC13, is open-drain output */
+#define LL_RTC_ALARM_OUTPUTTYPE_PUSHPULL   RTC__ALARMOUTTYPE /*!< RTC_ALARM, when mapped on PC13, is push-pull output */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_OUTPUTPOLARITY_PIN  OUTPUT POLARITY PIN
+  * @{
+  */
+#define LL_RTC_OUTPUTPOLARITY_PIN_HIGH     0x00000000U           /*!< Pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL)*/
+#define LL_RTC_OUTPUTPOLARITY_PIN_LOW      RTC_CR_POL            /*!< Pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL) */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_TIME_FORMAT TIME FORMAT
+  * @{
+  */
+#define LL_RTC_TIME_FORMAT_AM_OR_24        0x00000000U           /*!< AM or 24-hour format */
+#define LL_RTC_TIME_FORMAT_PM              RTC_TR_PM             /*!< PM */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_SHIFT_SECOND  SHIFT SECOND
+  * @{
+  */
+#define LL_RTC_SHIFT_SECOND_DELAY          0x00000000U           /* Delay (seconds) = SUBFS / (PREDIV_S + 1) */
+#define LL_RTC_SHIFT_SECOND_ADVANCE        RTC_SHIFTR_ADD1S      /* Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))) */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_ALMA_MASK  ALARMA MASK
+  * @{
+  */
+#define LL_RTC_ALMA_MASK_NONE              0x00000000U             /*!< No masks applied on Alarm A*/
+#define LL_RTC_ALMA_MASK_DATEWEEKDAY       RTC_ALRMAR_MSK4         /*!< Date/day do not care in Alarm A comparison */
+#define LL_RTC_ALMA_MASK_HOURS             RTC_ALRMAR_MSK3         /*!< Hours do not care in Alarm A comparison */
+#define LL_RTC_ALMA_MASK_MINUTES           RTC_ALRMAR_MSK2         /*!< Minutes do not care in Alarm A comparison */
+#define LL_RTC_ALMA_MASK_SECONDS           RTC_ALRMAR_MSK1         /*!< Seconds do not care in Alarm A comparison */
+#define LL_RTC_ALMA_MASK_ALL               (RTC_ALRMAR_MSK4 | RTC_ALRMAR_MSK3 | RTC_ALRMAR_MSK2 | RTC_ALRMAR_MSK1) /*!< Masks all */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_ALMA_TIME_FORMAT  ALARMA TIME FORMAT
+  * @{
+  */
+#define LL_RTC_ALMA_TIME_FORMAT_AM         0x00000000U           /*!< AM or 24-hour format */
+#define LL_RTC_ALMA_TIME_FORMAT_PM         RTC_ALRMAR_PM         /*!< PM */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_WAKEUPCLOCK_DIV  WAKEUP CLOCK DIV
+  * @{
+  */
+#define LL_RTC_WAKEUPCLOCK_DIV_16          0x00000000U                           /*!< RTC/16 clock is selected */
+#define LL_RTC_WAKEUPCLOCK_DIV_8           (RTC_CR_WUCKSEL_0)                    /*!< RTC/8 clock is selected */
+#define LL_RTC_WAKEUPCLOCK_DIV_4           (RTC_CR_WUCKSEL_1)                    /*!< RTC/4 clock is selected */
+#define LL_RTC_WAKEUPCLOCK_DIV_2           (RTC_CR_WUCKSEL_1 | RTC_CR_WUCKSEL_0) /*!< RTC/2 clock is selected */
+#define LL_RTC_WAKEUPCLOCK_CKSPRE          (RTC_CR_WUCKSEL_2)                    /*!< ck_spre (usually 1 Hz) clock is selected */
+#define LL_RTC_WAKEUPCLOCK_CKSPRE_WUT      (RTC_CR_WUCKSEL_2 | RTC_CR_WUCKSEL_1) /*!< ck_spre (usually 1 Hz) clock is selected and 2exp16 is added to the WUT counter value*/
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_BKP  BACKUP
+  * @{
+  */
+#define LL_RTC_BKP_DR0                     0x00000000U
+#define LL_RTC_BKP_DR1                     0x00000001U
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_CALIB_OUTPUT  Calibration output
+  * @{
+  */
+#define LL_RTC_CALIB_OUTPUT_NONE           0x00000000U                 /*!< Calibration output disabled */
+#define LL_RTC_CALIB_OUTPUT_1HZ            (RTC_CR_COE | RTC_CR_COSEL) /*!< Calibration output is 1 Hz */
+#define LL_RTC_CALIB_OUTPUT_512HZ          (RTC_CR_COE)                /*!< Calibration output is 512 Hz */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_CALIB_INSERTPULSE  Calibration pulse insertion
+  * @{
+  */
+#define LL_RTC_CALIB_INSERTPULSE_NONE      0x00000000U           /*!< No RTCCLK pulses are added */
+#define LL_RTC_CALIB_INSERTPULSE_SET       RTC_CALR_CALP         /*!< One RTCCLK pulse is effectively inserted every 2exp11 pulses (frequency increased by 488.5 ppm) */
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EC_CALIB_PERIOD  Calibration period
+  * @{
+  */
+#define LL_RTC_CALIB_PERIOD_32SEC          0x00000000U           /*!< Use a 32-second calibration cycle period */
+#define LL_RTC_CALIB_PERIOD_16SEC          RTC_CALR_CALW16       /*!< Use a 16-second calibration cycle period */
+#define LL_RTC_CALIB_PERIOD_8SEC           RTC_CALR_CALW8        /*!< Use a 8-second calibration cycle period */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported macro ------------------------------------------------------------*/
+/** @defgroup RTC_LL_Exported_Macros RTC Exported Macros
+  * @{
+  */
+
+/** @defgroup RTC_LL_EM_WRITE_READ Common Write and read registers Macros
+  * @{
+  */
+
+/**
+  * @brief  Write a value in RTC register
+  * @param  __INSTANCE__ RTC Instance
+  * @param  __REG__ Register to be written
+  * @param  __VALUE__ Value to be written in the register
+  * @retval None
+  */
+#define LL_RTC_WriteReg(__INSTANCE__, __REG__, __VALUE__) WRITE_REG(__INSTANCE__->__REG__, (__VALUE__))
+
+/**
+  * @brief  Read a value in RTC register
+  * @param  __INSTANCE__ RTC Instance
+  * @param  __REG__ Register to be read
+  * @retval Register value
+  */
+#define LL_RTC_ReadReg(__INSTANCE__, __REG__) READ_REG(__INSTANCE__->__REG__)
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EM_Convert Convert helper Macros
+  * @{
+  */
+
+/**
+  * @brief  Helper macro to convert a value from 2 digit decimal format to BCD format
+  * @param  __VALUE__ Byte to be converted
+  * @retval Converted byte
+  */
+#define __LL_RTC_CONVERT_BIN2BCD(__VALUE__) (uint8_t)((((__VALUE__) / 10U) << 4U) | ((__VALUE__) % 10U))
+
+/**
+  * @brief  Helper macro to convert a value from BCD format to 2 digit decimal format
+  * @param  __VALUE__ BCD value to be converted
+  * @retval Converted byte
+  */
+#define __LL_RTC_CONVERT_BCD2BIN(__VALUE__) (uint8_t)(((uint8_t)((__VALUE__) & (uint8_t)0xF0U) >> (uint8_t)0x4U) * 10U + ((__VALUE__) & (uint8_t)0x0FU))
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EM_Date Date helper Macros
+  * @{
+  */
+
+/**
+  * @brief  Helper macro to retrieve weekday.
+  * @param  __RTC_DATE__ Date returned by @ref  LL_RTC_DATE_Get function.
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_WEEKDAY_MONDAY
+  *         @arg @ref LL_RTC_WEEKDAY_TUESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_WEDNESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_THURSDAY
+  *         @arg @ref LL_RTC_WEEKDAY_FRIDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SATURDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SUNDAY
+  */
+#define __LL_RTC_GET_WEEKDAY(__RTC_DATE__) (((__RTC_DATE__) >> RTC_OFFSET_WEEKDAY) & 0x000000FFU)
+
+/**
+  * @brief  Helper macro to retrieve Year in BCD format
+  * @param  __RTC_DATE__ Value returned by @ref  LL_RTC_DATE_Get
+  * @retval Year in BCD format (0x00 . . . 0x99)
+  */
+#define __LL_RTC_GET_YEAR(__RTC_DATE__) ((__RTC_DATE__) & 0x000000FFU)
+
+/**
+  * @brief  Helper macro to retrieve Month in BCD format
+  * @param  __RTC_DATE__ Value returned by @ref  LL_RTC_DATE_Get
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_MONTH_JANUARY
+  *         @arg @ref LL_RTC_MONTH_FEBRUARY
+  *         @arg @ref LL_RTC_MONTH_MARCH
+  *         @arg @ref LL_RTC_MONTH_APRIL
+  *         @arg @ref LL_RTC_MONTH_MAY
+  *         @arg @ref LL_RTC_MONTH_JUNE
+  *         @arg @ref LL_RTC_MONTH_JULY
+  *         @arg @ref LL_RTC_MONTH_AUGUST
+  *         @arg @ref LL_RTC_MONTH_SEPTEMBER
+  *         @arg @ref LL_RTC_MONTH_OCTOBER
+  *         @arg @ref LL_RTC_MONTH_NOVEMBER
+  *         @arg @ref LL_RTC_MONTH_DECEMBER
+  */
+#define __LL_RTC_GET_MONTH(__RTC_DATE__) (((__RTC_DATE__) >>RTC_OFFSET_MONTH) & 0x000000FFU)
+
+/**
+  * @brief  Helper macro to retrieve Day in BCD format
+  * @param  __RTC_DATE__ Value returned by @ref  LL_RTC_DATE_Get
+  * @retval Day in BCD format (0x01 . . . 0x31)
+  */
+#define __LL_RTC_GET_DAY(__RTC_DATE__) (((__RTC_DATE__) >>RTC_OFFSET_DAY) & 0x000000FFU)
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EM_Time Time helper Macros
+  * @{
+  */
+
+/**
+  * @brief  Helper macro to retrieve hour in BCD format
+  * @param  __RTC_TIME__ RTC time returned by @ref LL_RTC_TIME_Get function
+  * @retval Hours in BCD format (0x01. . .0x12 or between Min_Data=0x00 and Max_Data=0x23)
+  */
+#define __LL_RTC_GET_HOUR(__RTC_TIME__) (((__RTC_TIME__) >> RTC_OFFSET_HOUR) & 0x000000FFU)
+
+/**
+  * @brief  Helper macro to retrieve minute in BCD format
+  * @param  __RTC_TIME__ RTC time returned by @ref LL_RTC_TIME_Get function
+  * @retval Minutes in BCD format (0x00. . .0x59)
+  */
+#define __LL_RTC_GET_MINUTE(__RTC_TIME__) (((__RTC_TIME__) >> RTC_OFFSET_MINUTE) & 0x000000FFU)
+
+/**
+  * @brief  Helper macro to retrieve second in BCD format
+  * @param  __RTC_TIME__ RTC time returned by @ref LL_RTC_TIME_Get function
+  * @retval Seconds in  format (0x00. . .0x59)
+  */
+#define __LL_RTC_GET_SECOND(__RTC_TIME__) ((__RTC_TIME__) & 0x000000FFU)
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/* Exported functions --------------------------------------------------------*/
+/** @defgroup RTC_LL_Exported_Functions RTC Exported Functions
+  * @{
+  */
+
+/** @defgroup RTC_LL_EF_Configuration Configuration
+  * @{
+  */
+
+/**
+  * @brief  Set Hours format (24 hour/day or AM/PM hour format)
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   It can be written in initialization mode only (@ref LL_RTC_EnableInitMode function)
+  * @rmtoll CR           FMT           LL_RTC_SetHourFormat
+  * @param  RTCx RTC Instance
+  * @param  HourFormat This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_HOURFORMAT_24HOUR
+  *         @arg @ref LL_RTC_HOURFORMAT_AMPM
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_SetHourFormat(RTC_TypeDef *RTCx, uint32_t HourFormat)
+{
+  MODIFY_REG(RTCx->CR, RTC_CR_FMT, HourFormat);
+}
+
+/**
+  * @brief  Get Hours format (24 hour/day or AM/PM hour format)
+  * @rmtoll CR           FMT           LL_RTC_GetHourFormat
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_HOURFORMAT_24HOUR
+  *         @arg @ref LL_RTC_HOURFORMAT_AMPM
+  */
+__STATIC_INLINE uint32_t LL_RTC_GetHourFormat(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_FMT));
+}
+
+/**
+  * @brief  Select the flag to be routed to RTC_ALARM output
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           OSEL          LL_RTC_SetAlarmOutEvent
+  * @param  RTCx RTC Instance
+  * @param  AlarmOutput This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_ALARMOUT_DISABLE
+  *         @arg @ref LL_RTC_ALARMOUT_ALMA
+  *         @arg @ref LL_RTC_ALARMOUT_ALMB
+  *         @arg @ref LL_RTC_ALARMOUT_WAKEUP
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_SetAlarmOutEvent(RTC_TypeDef *RTCx, uint32_t AlarmOutput)
+{
+  MODIFY_REG(RTCx->CR, RTC_CR_OSEL, AlarmOutput);
+}
+
+/**
+  * @brief  Get the flag to be routed to RTC_ALARM output
+  * @rmtoll CR           OSEL          LL_RTC_GetAlarmOutEvent
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_ALARMOUT_DISABLE
+  *         @arg @ref LL_RTC_ALARMOUT_ALMA
+  *         @arg @ref LL_RTC_ALARMOUT_ALMB
+  *         @arg @ref LL_RTC_ALARMOUT_WAKEUP
+  */
+__STATIC_INLINE uint32_t LL_RTC_GetAlarmOutEvent(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_OSEL));
+}
+
+/**
+  * @brief  Enable initialization mode
+  * @note   Initialization mode is used to program time and date register (RTC_TR and RTC_DR)
+  *         and prescaler register (RTC_PRER).
+  *         Counters are stopped and start counting from the new value when INIT is reset.
+  * @rmtoll ISR          INIT          LL_RTC_EnableInitMode
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_EnableInitMode(RTC_TypeDef *RTCx)
+{
+  /* Set the Initialization mode */
+  WRITE_REG(RTCx->ISR, RTC_INIT_MASK);
+}
+
+/**
+  * @brief  Disable initialization mode (Free running mode)
+  * @rmtoll ISR          INIT          LL_RTC_DisableInitMode
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DisableInitMode(RTC_TypeDef *RTCx)
+{
+  /* Exit Initialization mode */
+  WRITE_REG(RTCx->ISR, (uint32_t)~RTC_ISR_INIT);
+}
+
+/**
+  * @brief  Set Output polarity (pin is low when ALRAF/ALRBF/WUTF is asserted)
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           POL           LL_RTC_SetOutputPolarity
+  * @param  RTCx RTC Instance
+  * @param  Polarity This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_OUTPUTPOLARITY_PIN_HIGH
+  *         @arg @ref LL_RTC_OUTPUTPOLARITY_PIN_LOW
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_SetOutputPolarity(RTC_TypeDef *RTCx, uint32_t Polarity)
+{
+  MODIFY_REG(RTCx->CR, RTC_CR_POL, Polarity);
+}
+
+/**
+  * @brief  Get Output polarity
+  * @rmtoll CR           POL           LL_RTC_GetOutputPolarity
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_OUTPUTPOLARITY_PIN_HIGH
+  *         @arg @ref LL_RTC_OUTPUTPOLARITY_PIN_LOW
+  */
+__STATIC_INLINE uint32_t LL_RTC_GetOutputPolarity(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_POL));
+}
+
+/**
+  * @brief  Enable Bypass the shadow registers
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           BYPSHAD       LL_RTC_EnableShadowRegBypass
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_EnableShadowRegBypass(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_BYPSHAD);
+}
+
+/**
+  * @brief  Disable Bypass the shadow registers
+  * @rmtoll CR           BYPSHAD       LL_RTC_DisableShadowRegBypass
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DisableShadowRegBypass(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->CR, RTC_CR_BYPSHAD);
+}
+
+/**
+  * @brief  Check if Shadow registers bypass is enabled or not.
+  * @rmtoll CR           BYPSHAD       LL_RTC_IsShadowRegBypassEnabled
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsShadowRegBypassEnabled(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->CR, RTC_CR_BYPSHAD) == (RTC_CR_BYPSHAD)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Set Asynchronous prescaler factor
+  * @rmtoll PRER         PREDIV_A      LL_RTC_SetAsynchPrescaler
+  * @param  RTCx RTC Instance
+  * @param  AsynchPrescaler Value between Min_Data = 0 and Max_Data = 0x7F
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_SetAsynchPrescaler(RTC_TypeDef *RTCx, uint32_t AsynchPrescaler)
+{
+  MODIFY_REG(RTCx->PRER, RTC_PRER_PREDIV_A, AsynchPrescaler << RTC_PRER_PREDIV_A_Pos);
+}
+
+/**
+  * @brief  Set Synchronous prescaler factor
+  * @rmtoll PRER         PREDIV_S      LL_RTC_SetSynchPrescaler
+  * @param  RTCx RTC Instance
+  * @param  SynchPrescaler Value between Min_Data = 0 and Max_Data = 0x7FFF
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_SetSynchPrescaler(RTC_TypeDef *RTCx, uint32_t SynchPrescaler)
+{
+  MODIFY_REG(RTCx->PRER, RTC_PRER_PREDIV_S, SynchPrescaler);
+}
+
+/**
+  * @brief  Get Asynchronous prescaler factor
+  * @rmtoll PRER         PREDIV_A      LL_RTC_GetAsynchPrescaler
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data = 0 and Max_Data = 0x7F
+  */
+__STATIC_INLINE uint32_t LL_RTC_GetAsynchPrescaler(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->PRER, RTC_PRER_PREDIV_A) >> RTC_PRER_PREDIV_A_Pos);
+}
+
+/**
+  * @brief  Get Synchronous prescaler factor
+  * @rmtoll PRER         PREDIV_S      LL_RTC_GetSynchPrescaler
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data = 0 and Max_Data = 0x7FFF
+  */
+__STATIC_INLINE uint32_t LL_RTC_GetSynchPrescaler(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->PRER, RTC_PRER_PREDIV_S));
+}
+
+/**
+  * @brief  Enable the write protection for RTC registers.
+  * @rmtoll WPR          KEY           LL_RTC_EnableWriteProtection
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_EnableWriteProtection(RTC_TypeDef *RTCx)
+{
+  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_DISABLE);
+}
+
+/**
+  * @brief  Disable the write protection for RTC registers.
+  * @rmtoll WPR          KEY           LL_RTC_DisableWriteProtection
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DisableWriteProtection(RTC_TypeDef *RTCx)
+{
+  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_ENABLE_1);
+  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_ENABLE_2);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_Time Time
+  * @{
+  */
+
+/**
+  * @brief  Set time format (AM/24-hour or PM notation)
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   It can be written in initialization mode only (@ref LL_RTC_EnableInitMode function)
+  * @rmtoll TR           PM            LL_RTC_TIME_SetFormat
+  * @param  RTCx RTC Instance
+  * @param  TimeFormat This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_TIME_FORMAT_AM_OR_24
+  *         @arg @ref LL_RTC_TIME_FORMAT_PM
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_SetFormat(RTC_TypeDef *RTCx, uint32_t TimeFormat)
+{
+  MODIFY_REG(RTCx->TR, RTC_TR_PM, TimeFormat);
+}
+
+/**
+  * @brief  Get time format (AM or PM notation)
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
+  *       shadow registers until RTC_DR is read (LL_RTC_ReadReg(RTC, DR)).
+  * @rmtoll TR           PM            LL_RTC_TIME_GetFormat
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_TIME_FORMAT_AM_OR_24
+  *         @arg @ref LL_RTC_TIME_FORMAT_PM
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_GetFormat(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->TR, RTC_TR_PM));
+}
+
+/**
+  * @brief  Set Hours in BCD format
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   It can be written in initialization mode only (@ref LL_RTC_EnableInitMode function)
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert hour from binary to BCD format
+  * @rmtoll TR           HT            LL_RTC_TIME_SetHour\n
+  *         TR           HU            LL_RTC_TIME_SetHour
+  * @param  RTCx RTC Instance
+  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_SetHour(RTC_TypeDef *RTCx, uint32_t Hours)
+{
+  MODIFY_REG(RTCx->TR, (RTC_TR_HT | RTC_TR_HU),
+             (((Hours & 0xF0U) << (RTC_TR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_TR_HU_Pos)));
+}
+
+/**
+  * @brief  Get Hours in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
+  *       shadow registers until RTC_DR is read (LL_RTC_ReadReg(RTC, DR)).
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert hour from BCD to
+  *       Binary format
+  * @rmtoll TR           HT            LL_RTC_TIME_GetHour\n
+  *         TR           HU            LL_RTC_TIME_GetHour
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_GetHour(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->TR, (RTC_TR_HT | RTC_TR_HU))) >> RTC_TR_HU_Pos);
+}
+
+/**
+  * @brief  Set Minutes in BCD format
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   It can be written in initialization mode only (@ref LL_RTC_EnableInitMode function)
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Minutes from binary to BCD format
+  * @rmtoll TR           MNT           LL_RTC_TIME_SetMinute\n
+  *         TR           MNU           LL_RTC_TIME_SetMinute
+  * @param  RTCx RTC Instance
+  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_SetMinute(RTC_TypeDef *RTCx, uint32_t Minutes)
+{
+  MODIFY_REG(RTCx->TR, (RTC_TR_MNT | RTC_TR_MNU),
+             (((Minutes & 0xF0U) << (RTC_TR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_TR_MNU_Pos)));
+}
+
+/**
+  * @brief  Get Minutes in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
+  *       shadow registers until RTC_DR is read (LL_RTC_ReadReg(RTC, DR)).
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert minute from BCD
+  *       to Binary format
+  * @rmtoll TR           MNT           LL_RTC_TIME_GetMinute\n
+  *         TR           MNU           LL_RTC_TIME_GetMinute
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0x59
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_GetMinute(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->TR, (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
+}
+
+/**
+  * @brief  Set Seconds in BCD format
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   It can be written in initialization mode only (@ref LL_RTC_EnableInitMode function)
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Seconds from binary to BCD format
+  * @rmtoll TR           ST            LL_RTC_TIME_SetSecond\n
+  *         TR           SU            LL_RTC_TIME_SetSecond
+  * @param  RTCx RTC Instance
+  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_SetSecond(RTC_TypeDef *RTCx, uint32_t Seconds)
+{
+  MODIFY_REG(RTCx->TR, (RTC_TR_ST | RTC_TR_SU),
+             (((Seconds & 0xF0U) << (RTC_TR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_TR_SU_Pos)));
+}
+
+/**
+  * @brief  Get Seconds in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
+  *       shadow registers until RTC_DR is read (LL_RTC_ReadReg(RTC, DR)).
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Seconds from BCD
+  *       to Binary format
+  * @rmtoll TR           ST            LL_RTC_TIME_GetSecond\n
+  *         TR           SU            LL_RTC_TIME_GetSecond
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0x59
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_GetSecond(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->TR, (RTC_TR_ST | RTC_TR_SU)) >> RTC_TR_SU_Pos);
+}
+
+/**
+  * @brief  Set time (hour, minute and second) in BCD format
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   It can be written in initialization mode only (@ref LL_RTC_EnableInitMode function)
+  * @note TimeFormat and Hours should follow the same format
+  * @rmtoll TR           PM            LL_RTC_TIME_Config\n
+  *         TR           HT            LL_RTC_TIME_Config\n
+  *         TR           HU            LL_RTC_TIME_Config\n
+  *         TR           MNT           LL_RTC_TIME_Config\n
+  *         TR           MNU           LL_RTC_TIME_Config\n
+  *         TR           ST            LL_RTC_TIME_Config\n
+  *         TR           SU            LL_RTC_TIME_Config
+  * @param  RTCx RTC Instance
+  * @param  Format12_24 This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_TIME_FORMAT_AM_OR_24
+  *         @arg @ref LL_RTC_TIME_FORMAT_PM
+  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
+  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
+  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_Config(RTC_TypeDef *RTCx, uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds)
+{
+  uint32_t temp;
+
+  temp = Format12_24                                                                            | \
+         (((Hours   & 0xF0U) << (RTC_TR_HT_Pos  - 4U)) | ((Hours & 0x0FU) << RTC_TR_HU_Pos))    | \
+         (((Minutes & 0xF0U) << (RTC_TR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_TR_MNU_Pos)) | \
+         (((Seconds & 0xF0U) << (RTC_TR_ST_Pos  - 4U)) | ((Seconds & 0x0FU) << RTC_TR_SU_Pos));
+  MODIFY_REG(RTCx->TR, (RTC_TR_PM | RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU), temp);
+}
+
+/**
+  * @brief  Get time (hour, minute and second) in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note Read either RTC_SSR or RTC_TR locks the values in the higher-order calendar
+  *       shadow registers until RTC_DR is read (LL_RTC_ReadReg(RTC, DR)).
+  * @note helper macros __LL_RTC_GET_HOUR, __LL_RTC_GET_MINUTE and __LL_RTC_GET_SECOND
+  *       are available to get independently each parameter.
+  * @rmtoll TR           HT            LL_RTC_TIME_Get\n
+  *         TR           HU            LL_RTC_TIME_Get\n
+  *         TR           MNT           LL_RTC_TIME_Get\n
+  *         TR           MNU           LL_RTC_TIME_Get\n
+  *         TR           ST            LL_RTC_TIME_Get\n
+  *         TR           SU            LL_RTC_TIME_Get
+  * @param  RTCx RTC Instance
+  * @retval Combination of hours, minutes and seconds (Format: 0x00HHMMSS).
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_Get(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->TR, (RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU)));
+}
+
+/**
+  * @brief  Memorize whether the daylight saving time change has been performed
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           BKP           LL_RTC_TIME_EnableDayLightStore
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_EnableDayLightStore(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_BKP);
+}
+
+/**
+  * @brief  Disable memorization whether the daylight saving time change has been performed.
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           BKP           LL_RTC_TIME_DisableDayLightStore
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_DisableDayLightStore(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->CR, RTC_CR_BKP);
+}
+
+/**
+  * @brief  Check if RTC Day Light Saving stored operation has been enabled or not
+  * @rmtoll CR           BKP           LL_RTC_TIME_IsDayLightStoreEnabled
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_IsDayLightStoreEnabled(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->CR, RTC_CR_BKP) == (RTC_CR_BKP)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Subtract 1 hour (winter time change)
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           SUB1H         LL_RTC_TIME_DecHour
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_DecHour(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_SUB1H);
+}
+
+/**
+  * @brief  Add 1 hour (summer time change)
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           ADD1H         LL_RTC_TIME_IncHour
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_IncHour(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_ADD1H);
+}
+
+/**
+  * @brief  Get subseconds value in the synchronous prescaler counter.
+  * @note  You can use both SubSeconds value and SecondFraction (PREDIV_S through
+  *        LL_RTC_GetSynchPrescaler function) terms returned to convert Calendar
+  *        SubSeconds value in second fraction ratio with time unit following
+  *        generic formula:
+  *          ==> Seconds fraction ratio * time_unit =
+  *                 [(SecondFraction-SubSeconds)/(SecondFraction+1)] * time_unit
+  *        This conversion can be performed only if no shift operation is pending
+  *        (ie. SHFP=0) when PREDIV_S >= SS.
+  * @rmtoll SSR          SS            LL_RTC_TIME_GetSubSecond
+  * @param  RTCx RTC Instance
+  * @retval Subseconds value (number between 0 and 65535)
+  */
+__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
+}
+
+/**
+  * @brief  Synchronize to a remote clock with a high degree of precision.
+  * @note   This operation effectively subtracts from (delays) or advance the clock of a fraction of a second.
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   When REFCKON is set, firmware must not write to Shift control register.
+  * @rmtoll SHIFTR       ADD1S         LL_RTC_TIME_Synchronize\n
+  *         SHIFTR       SUBFS         LL_RTC_TIME_Synchronize
+  * @param  RTCx RTC Instance
+  * @param  ShiftSecond This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_SHIFT_SECOND_DELAY
+  *         @arg @ref LL_RTC_SHIFT_SECOND_ADVANCE
+  * @param  Fraction Number of Seconds Fractions (any value from 0 to 0x7FFF)
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_TIME_Synchronize(RTC_TypeDef *RTCx, uint32_t ShiftSecond, uint32_t Fraction)
+{
+  WRITE_REG(RTCx->SHIFTR, ShiftSecond | Fraction);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_Date Date
+  * @{
+  */
+
+/**
+  * @brief  Set Year in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Year from binary to BCD format
+  * @rmtoll DR           YT            LL_RTC_DATE_SetYear\n
+  *         DR           YU            LL_RTC_DATE_SetYear
+  * @param  RTCx RTC Instance
+  * @param  Year Value between Min_Data=0x00 and Max_Data=0x99
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DATE_SetYear(RTC_TypeDef *RTCx, uint32_t Year)
+{
+  MODIFY_REG(RTCx->DR, (RTC_DR_YT | RTC_DR_YU),
+             (((Year & 0xF0U) << (RTC_DR_YT_Pos - 4U)) | ((Year & 0x0FU) << RTC_DR_YU_Pos)));
+}
+
+/**
+  * @brief  Get Year in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Year from BCD to Binary format
+  * @rmtoll DR           YT            LL_RTC_DATE_GetYear\n
+  *         DR           YU            LL_RTC_DATE_GetYear
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0x99
+  */
+__STATIC_INLINE uint32_t LL_RTC_DATE_GetYear(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->DR, (RTC_DR_YT | RTC_DR_YU))) >> RTC_DR_YU_Pos);
+}
+
+/**
+  * @brief  Set Week day
+  * @rmtoll DR           WDU           LL_RTC_DATE_SetWeekDay
+  * @param  RTCx RTC Instance
+  * @param  WeekDay This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_WEEKDAY_MONDAY
+  *         @arg @ref LL_RTC_WEEKDAY_TUESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_WEDNESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_THURSDAY
+  *         @arg @ref LL_RTC_WEEKDAY_FRIDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SATURDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SUNDAY
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DATE_SetWeekDay(RTC_TypeDef *RTCx, uint32_t WeekDay)
+{
+  MODIFY_REG(RTCx->DR, RTC_DR_WDU, WeekDay << RTC_DR_WDU_Pos);
+}
+
+/**
+  * @brief  Get Week day
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @rmtoll DR           WDU           LL_RTC_DATE_GetWeekDay
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_WEEKDAY_MONDAY
+  *         @arg @ref LL_RTC_WEEKDAY_TUESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_WEDNESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_THURSDAY
+  *         @arg @ref LL_RTC_WEEKDAY_FRIDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SATURDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SUNDAY
+  */
+__STATIC_INLINE uint32_t LL_RTC_DATE_GetWeekDay(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->DR, RTC_DR_WDU) >> RTC_DR_WDU_Pos);
+}
+
+/**
+  * @brief  Set Month in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Month from binary to BCD format
+  * @rmtoll DR           MT            LL_RTC_DATE_SetMonth\n
+  *         DR           MU            LL_RTC_DATE_SetMonth
+  * @param  RTCx RTC Instance
+  * @param  Month This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_MONTH_JANUARY
+  *         @arg @ref LL_RTC_MONTH_FEBRUARY
+  *         @arg @ref LL_RTC_MONTH_MARCH
+  *         @arg @ref LL_RTC_MONTH_APRIL
+  *         @arg @ref LL_RTC_MONTH_MAY
+  *         @arg @ref LL_RTC_MONTH_JUNE
+  *         @arg @ref LL_RTC_MONTH_JULY
+  *         @arg @ref LL_RTC_MONTH_AUGUST
+  *         @arg @ref LL_RTC_MONTH_SEPTEMBER
+  *         @arg @ref LL_RTC_MONTH_OCTOBER
+  *         @arg @ref LL_RTC_MONTH_NOVEMBER
+  *         @arg @ref LL_RTC_MONTH_DECEMBER
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DATE_SetMonth(RTC_TypeDef *RTCx, uint32_t Month)
+{
+  MODIFY_REG(RTCx->DR, (RTC_DR_MT | RTC_DR_MU),
+             (((Month & 0xF0U) << (RTC_DR_MT_Pos - 4U)) | ((Month & 0x0FU) << RTC_DR_MU_Pos)));
+}
+
+/**
+  * @brief  Get Month in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Month from BCD to Binary format
+  * @rmtoll DR           MT            LL_RTC_DATE_GetMonth\n
+  *         DR           MU            LL_RTC_DATE_GetMonth
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_MONTH_JANUARY
+  *         @arg @ref LL_RTC_MONTH_FEBRUARY
+  *         @arg @ref LL_RTC_MONTH_MARCH
+  *         @arg @ref LL_RTC_MONTH_APRIL
+  *         @arg @ref LL_RTC_MONTH_MAY
+  *         @arg @ref LL_RTC_MONTH_JUNE
+  *         @arg @ref LL_RTC_MONTH_JULY
+  *         @arg @ref LL_RTC_MONTH_AUGUST
+  *         @arg @ref LL_RTC_MONTH_SEPTEMBER
+  *         @arg @ref LL_RTC_MONTH_OCTOBER
+  *         @arg @ref LL_RTC_MONTH_NOVEMBER
+  *         @arg @ref LL_RTC_MONTH_DECEMBER
+  */
+__STATIC_INLINE uint32_t LL_RTC_DATE_GetMonth(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->DR, (RTC_DR_MT | RTC_DR_MU))) >> RTC_DR_MU_Pos);
+}
+
+/**
+  * @brief  Set Day in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Day from binary to BCD format
+  * @rmtoll DR           DT            LL_RTC_DATE_SetDay\n
+  *         DR           DU            LL_RTC_DATE_SetDay
+  * @param  RTCx RTC Instance
+  * @param  Day Value between Min_Data=0x01 and Max_Data=0x31
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DATE_SetDay(RTC_TypeDef *RTCx, uint32_t Day)
+{
+  MODIFY_REG(RTCx->DR, (RTC_DR_DT | RTC_DR_DU),
+             (((Day & 0xF0U) << (RTC_DR_DT_Pos - 4U)) | ((Day & 0x0FU) << RTC_DR_DU_Pos)));
+}
+
+/**
+  * @brief  Get Day in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Day from BCD to Binary format
+  * @rmtoll DR           DT            LL_RTC_DATE_GetDay\n
+  *         DR           DU            LL_RTC_DATE_GetDay
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x01 and Max_Data=0x31
+  */
+__STATIC_INLINE uint32_t LL_RTC_DATE_GetDay(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->DR, (RTC_DR_DT | RTC_DR_DU))) >> RTC_DR_DU_Pos);
+}
+
+/**
+  * @brief  Set date (WeekDay, Day, Month and Year) in BCD format
+  * @rmtoll DR           WDU           LL_RTC_DATE_Config\n
+  *         DR           MT            LL_RTC_DATE_Config\n
+  *         DR           MU            LL_RTC_DATE_Config\n
+  *         DR           DT            LL_RTC_DATE_Config\n
+  *         DR           DU            LL_RTC_DATE_Config\n
+  *         DR           YT            LL_RTC_DATE_Config\n
+  *         DR           YU            LL_RTC_DATE_Config
+  * @param  RTCx RTC Instance
+  * @param  WeekDay This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_WEEKDAY_MONDAY
+  *         @arg @ref LL_RTC_WEEKDAY_TUESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_WEDNESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_THURSDAY
+  *         @arg @ref LL_RTC_WEEKDAY_FRIDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SATURDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SUNDAY
+  * @param  Day Value between Min_Data=0x01 and Max_Data=0x31
+  * @param  Month This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_MONTH_JANUARY
+  *         @arg @ref LL_RTC_MONTH_FEBRUARY
+  *         @arg @ref LL_RTC_MONTH_MARCH
+  *         @arg @ref LL_RTC_MONTH_APRIL
+  *         @arg @ref LL_RTC_MONTH_MAY
+  *         @arg @ref LL_RTC_MONTH_JUNE
+  *         @arg @ref LL_RTC_MONTH_JULY
+  *         @arg @ref LL_RTC_MONTH_AUGUST
+  *         @arg @ref LL_RTC_MONTH_SEPTEMBER
+  *         @arg @ref LL_RTC_MONTH_OCTOBER
+  *         @arg @ref LL_RTC_MONTH_NOVEMBER
+  *         @arg @ref LL_RTC_MONTH_DECEMBER
+  * @param  Year Value between Min_Data=0x00 and Max_Data=0x99
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DATE_Config(RTC_TypeDef *RTCx, uint32_t WeekDay, uint32_t Day, uint32_t Month, uint32_t Year)
+{
+  uint32_t temp;
+
+  temp = (  WeekDay                                                    << RTC_DR_WDU_Pos) | \
+         (((Year  & 0xF0U) << (RTC_DR_YT_Pos - 4U)) | ((Year  & 0x0FU) << RTC_DR_YU_Pos)) | \
+         (((Month & 0xF0U) << (RTC_DR_MT_Pos - 4U)) | ((Month & 0x0FU) << RTC_DR_MU_Pos)) | \
+         (((Day   & 0xF0U) << (RTC_DR_DT_Pos - 4U)) | ((Day   & 0x0FU) << RTC_DR_DU_Pos));
+
+  MODIFY_REG(RTCx->DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU), temp);
+}
+
+/**
+  * @brief  Get date (WeekDay, Day, Month and Year) in BCD format
+  * @note if RTC shadow registers are not bypassed (BYPSHAD=0), need to check if RSF flag is set
+  *       before reading this bit
+  * @note helper macros __LL_RTC_GET_WEEKDAY, __LL_RTC_GET_YEAR, __LL_RTC_GET_MONTH,
+  * and __LL_RTC_GET_DAY are available to get independently each parameter.
+  * @rmtoll DR           WDU           LL_RTC_DATE_Get\n
+  *         DR           MT            LL_RTC_DATE_Get\n
+  *         DR           MU            LL_RTC_DATE_Get\n
+  *         DR           DT            LL_RTC_DATE_Get\n
+  *         DR           DU            LL_RTC_DATE_Get\n
+  *         DR           YT            LL_RTC_DATE_Get\n
+  *         DR           YU            LL_RTC_DATE_Get
+  * @param  RTCx RTC Instance
+  * @retval Combination of WeekDay, Day, Month and Year (Format: 0xWWDDMMYY).
+  */
+__STATIC_INLINE uint32_t LL_RTC_DATE_Get(RTC_TypeDef *RTCx)
+{
+  uint32_t temp;
+
+  temp = READ_BIT(RTCx->DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU));
+
+  return (uint32_t)((((temp &              RTC_DR_WDU) >> RTC_DR_WDU_Pos) << RTC_OFFSET_WEEKDAY) | \
+                    (((temp & (RTC_DR_DT | RTC_DR_DU)) >> RTC_DR_DU_Pos)  << RTC_OFFSET_DAY)     | \
+                    (((temp & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos)  << RTC_OFFSET_MONTH)   | \
+                     ((temp & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos));
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_ALARMA ALARMA
+  * @{
+  */
+
+/**
+  * @brief  Enable Alarm A
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           ALRAE         LL_RTC_ALMA_Enable
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_Enable(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_ALRAE);
+}
+
+/**
+  * @brief  Disable Alarm A
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           ALRAE         LL_RTC_ALMA_Disable
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_Disable(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->CR, RTC_CR_ALRAE);
+}
+
+/**
+  * @brief  Specify the Alarm A masks.
+  * @rmtoll ALRMAR       MSK4          LL_RTC_ALMA_SetMask\n
+  *         ALRMAR       MSK3          LL_RTC_ALMA_SetMask\n
+  *         ALRMAR       MSK2          LL_RTC_ALMA_SetMask\n
+  *         ALRMAR       MSK1          LL_RTC_ALMA_SetMask
+  * @param  RTCx RTC Instance
+  * @param  Mask This parameter can be a combination of the following values:
+  *         @arg @ref LL_RTC_ALMA_MASK_NONE
+  *         @arg @ref LL_RTC_ALMA_MASK_DATEWEEKDAY
+  *         @arg @ref LL_RTC_ALMA_MASK_HOURS
+  *         @arg @ref LL_RTC_ALMA_MASK_MINUTES
+  *         @arg @ref LL_RTC_ALMA_MASK_SECONDS
+  *         @arg @ref LL_RTC_ALMA_MASK_ALL
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetMask(RTC_TypeDef *RTCx, uint32_t Mask)
+{
+  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_MSK4 | RTC_ALRMAR_MSK3 | RTC_ALRMAR_MSK2 | RTC_ALRMAR_MSK1, Mask);
+}
+
+/**
+  * @brief  Get the Alarm A masks.
+  * @rmtoll ALRMAR       MSK4          LL_RTC_ALMA_GetMask\n
+  *         ALRMAR       MSK3          LL_RTC_ALMA_GetMask\n
+  *         ALRMAR       MSK2          LL_RTC_ALMA_GetMask\n
+  *         ALRMAR       MSK1          LL_RTC_ALMA_GetMask
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be can be a combination of the following values:
+  *         @arg @ref LL_RTC_ALMA_MASK_NONE
+  *         @arg @ref LL_RTC_ALMA_MASK_DATEWEEKDAY
+  *         @arg @ref LL_RTC_ALMA_MASK_HOURS
+  *         @arg @ref LL_RTC_ALMA_MASK_MINUTES
+  *         @arg @ref LL_RTC_ALMA_MASK_SECONDS
+  *         @arg @ref LL_RTC_ALMA_MASK_ALL
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetMask(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->ALRMAR, RTC_ALRMAR_MSK4 | RTC_ALRMAR_MSK3 | RTC_ALRMAR_MSK2 | RTC_ALRMAR_MSK1));
+}
+
+/**
+  * @brief  Enable AlarmA Week day selection (DU[3:0] represents the week day. DT[1:0] is do not care)
+  * @rmtoll ALRMAR       WDSEL         LL_RTC_ALMA_EnableWeekday
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_EnableWeekday(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->ALRMAR, RTC_ALRMAR_WDSEL);
+}
+
+/**
+  * @brief  Disable AlarmA Week day selection (DU[3:0] represents the date )
+  * @rmtoll ALRMAR       WDSEL         LL_RTC_ALMA_DisableWeekday
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_DisableWeekday(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->ALRMAR, RTC_ALRMAR_WDSEL);
+}
+
+/**
+  * @brief  Set ALARM A Day in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Day from binary to BCD format
+  * @rmtoll ALRMAR       DT            LL_RTC_ALMA_SetDay\n
+  *         ALRMAR       DU            LL_RTC_ALMA_SetDay
+  * @param  RTCx RTC Instance
+  * @param  Day Value between Min_Data=0x01 and Max_Data=0x31
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetDay(RTC_TypeDef *RTCx, uint32_t Day)
+{
+  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_DT | RTC_ALRMAR_DU),
+             (((Day & 0xF0U) << (RTC_ALRMAR_DT_Pos - 4U)) | ((Day & 0x0FU) << RTC_ALRMAR_DU_Pos)));
+}
+
+/**
+  * @brief  Get ALARM A Day in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Day from BCD to Binary format
+  * @rmtoll ALRMAR       DT            LL_RTC_ALMA_GetDay\n
+  *         ALRMAR       DU            LL_RTC_ALMA_GetDay
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x01 and Max_Data=0x31
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetDay(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_DT | RTC_ALRMAR_DU))) >> RTC_ALRMAR_DU_Pos);
+}
+
+/**
+  * @brief  Set ALARM A Weekday
+  * @rmtoll ALRMAR       DU            LL_RTC_ALMA_SetWeekDay
+  * @param  RTCx RTC Instance
+  * @param  WeekDay This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_WEEKDAY_MONDAY
+  *         @arg @ref LL_RTC_WEEKDAY_TUESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_WEDNESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_THURSDAY
+  *         @arg @ref LL_RTC_WEEKDAY_FRIDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SATURDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SUNDAY
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetWeekDay(RTC_TypeDef *RTCx, uint32_t WeekDay)
+{
+  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_DU, WeekDay << RTC_ALRMAR_DU_Pos);
+}
+
+/**
+  * @brief  Get ALARM A Weekday
+  * @rmtoll ALRMAR       DU            LL_RTC_ALMA_GetWeekDay
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_WEEKDAY_MONDAY
+  *         @arg @ref LL_RTC_WEEKDAY_TUESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_WEDNESDAY
+  *         @arg @ref LL_RTC_WEEKDAY_THURSDAY
+  *         @arg @ref LL_RTC_WEEKDAY_FRIDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SATURDAY
+  *         @arg @ref LL_RTC_WEEKDAY_SUNDAY
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetWeekDay(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->ALRMAR, RTC_ALRMAR_DU) >> RTC_ALRMAR_DU_Pos);
+}
+
+/**
+  * @brief  Set Alarm A time format (AM/24-hour or PM notation)
+  * @rmtoll ALRMAR       PM            LL_RTC_ALMA_SetTimeFormat
+  * @param  RTCx RTC Instance
+  * @param  TimeFormat This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_ALMA_TIME_FORMAT_AM
+  *         @arg @ref LL_RTC_ALMA_TIME_FORMAT_PM
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetTimeFormat(RTC_TypeDef *RTCx, uint32_t TimeFormat)
+{
+  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_PM, TimeFormat);
+}
+
+/**
+  * @brief  Get Alarm A time format (AM or PM notation)
+  * @rmtoll ALRMAR       PM            LL_RTC_ALMA_GetTimeFormat
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_ALMA_TIME_FORMAT_AM
+  *         @arg @ref LL_RTC_ALMA_TIME_FORMAT_PM
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetTimeFormat(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->ALRMAR, RTC_ALRMAR_PM));
+}
+
+/**
+  * @brief  Set ALARM A Hours in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Hours from binary to BCD format
+  * @rmtoll ALRMAR       HT            LL_RTC_ALMA_SetHour\n
+  *         ALRMAR       HU            LL_RTC_ALMA_SetHour
+  * @param  RTCx RTC Instance
+  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetHour(RTC_TypeDef *RTCx, uint32_t Hours)
+{
+  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_HT | RTC_ALRMAR_HU),
+             (((Hours & 0xF0U) << (RTC_ALRMAR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_ALRMAR_HU_Pos)));
+}
+
+/**
+  * @brief  Get ALARM A Hours in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Hours from BCD to Binary format
+  * @rmtoll ALRMAR       HT            LL_RTC_ALMA_GetHour\n
+  *         ALRMAR       HU            LL_RTC_ALMA_GetHour
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetHour(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_HT | RTC_ALRMAR_HU))) >> RTC_ALRMAR_HU_Pos);
+}
+
+/**
+  * @brief  Set ALARM A Minutes in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Minutes from binary to BCD format
+  * @rmtoll ALRMAR       MNT           LL_RTC_ALMA_SetMinute\n
+  *         ALRMAR       MNU           LL_RTC_ALMA_SetMinute
+  * @param  RTCx RTC Instance
+  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetMinute(RTC_TypeDef *RTCx, uint32_t Minutes)
+{
+  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU),
+             (((Minutes & 0xF0U) << (RTC_ALRMAR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_ALRMAR_MNU_Pos)));
+}
+
+/**
+  * @brief  Get ALARM A Minutes in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Minutes from BCD to Binary format
+  * @rmtoll ALRMAR       MNT           LL_RTC_ALMA_GetMinute\n
+  *         ALRMAR       MNU           LL_RTC_ALMA_GetMinute
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0x59
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetMinute(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU))) >> RTC_ALRMAR_MNU_Pos);
+}
+
+/**
+  * @brief  Set ALARM A Seconds in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BIN2BCD is available to convert Seconds from binary to BCD format
+  * @rmtoll ALRMAR       ST            LL_RTC_ALMA_SetSecond\n
+  *         ALRMAR       SU            LL_RTC_ALMA_SetSecond
+  * @param  RTCx RTC Instance
+  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetSecond(RTC_TypeDef *RTCx, uint32_t Seconds)
+{
+  MODIFY_REG(RTCx->ALRMAR, (RTC_ALRMAR_ST | RTC_ALRMAR_SU),
+             (((Seconds & 0xF0U) << (RTC_ALRMAR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_ALRMAR_SU_Pos)));
+}
+
+/**
+  * @brief  Get ALARM A Seconds in BCD format
+  * @note helper macro __LL_RTC_CONVERT_BCD2BIN is available to convert Seconds from BCD to Binary format
+  * @rmtoll ALRMAR       ST            LL_RTC_ALMA_GetSecond\n
+  *         ALRMAR       SU            LL_RTC_ALMA_GetSecond
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0x59
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetSecond(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((READ_BIT(RTCx->ALRMAR, (RTC_ALRMAR_ST | RTC_ALRMAR_SU))) >> RTC_ALRMAR_SU_Pos);
+}
+
+/**
+  * @brief  Set Alarm A Time (hour, minute and second) in BCD format
+  * @rmtoll ALRMAR       PM            LL_RTC_ALMA_ConfigTime\n
+  *         ALRMAR       HT            LL_RTC_ALMA_ConfigTime\n
+  *         ALRMAR       HU            LL_RTC_ALMA_ConfigTime\n
+  *         ALRMAR       MNT           LL_RTC_ALMA_ConfigTime\n
+  *         ALRMAR       MNU           LL_RTC_ALMA_ConfigTime\n
+  *         ALRMAR       ST            LL_RTC_ALMA_ConfigTime\n
+  *         ALRMAR       SU            LL_RTC_ALMA_ConfigTime
+  * @param  RTCx RTC Instance
+  * @param  Format12_24 This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_ALMA_TIME_FORMAT_AM
+  *         @arg @ref LL_RTC_ALMA_TIME_FORMAT_PM
+  * @param  Hours Value between Min_Data=0x01 and Max_Data=0x12 or between Min_Data=0x00 and Max_Data=0x23
+  * @param  Minutes Value between Min_Data=0x00 and Max_Data=0x59
+  * @param  Seconds Value between Min_Data=0x00 and Max_Data=0x59
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_ConfigTime(RTC_TypeDef *RTCx, uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds)
+{
+  uint32_t temp;
+
+  temp = Format12_24                                                                                    | \
+         (((Hours   & 0xF0U) << (RTC_ALRMAR_HT_Pos  - 4U)) | ((Hours   & 0x0FU) << RTC_ALRMAR_HU_Pos))  | \
+         (((Minutes & 0xF0U) << (RTC_ALRMAR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_ALRMAR_MNU_Pos)) | \
+         (((Seconds & 0xF0U) << (RTC_ALRMAR_ST_Pos  - 4U)) | ((Seconds & 0x0FU) << RTC_ALRMAR_SU_Pos));
+
+  MODIFY_REG(RTCx->ALRMAR, RTC_ALRMAR_PM | RTC_ALRMAR_HT | RTC_ALRMAR_HU | RTC_ALRMAR_MNT | RTC_ALRMAR_MNU | RTC_ALRMAR_ST | RTC_ALRMAR_SU, temp);
+}
+
+/**
+  * @brief  Get Alarm B Time (hour, minute and second) in BCD format
+  * @note helper macros __LL_RTC_GET_HOUR, __LL_RTC_GET_MINUTE and __LL_RTC_GET_SECOND
+  * are available to get independently each parameter.
+  * @rmtoll ALRMAR       HT            LL_RTC_ALMA_GetTime\n
+  *         ALRMAR       HU            LL_RTC_ALMA_GetTime\n
+  *         ALRMAR       MNT           LL_RTC_ALMA_GetTime\n
+  *         ALRMAR       MNU           LL_RTC_ALMA_GetTime\n
+  *         ALRMAR       ST            LL_RTC_ALMA_GetTime\n
+  *         ALRMAR       SU            LL_RTC_ALMA_GetTime
+  * @param  RTCx RTC Instance
+  * @retval Combination of hours, minutes and seconds.
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetTime(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)((LL_RTC_ALMA_GetHour(RTCx) << RTC_OFFSET_HOUR) | (LL_RTC_ALMA_GetMinute(RTCx) << RTC_OFFSET_MINUTE) | LL_RTC_ALMA_GetSecond(RTCx));
+}
+
+/**
+  * @brief  Mask the most-significant bits of the subseconds field starting from
+  *         the bit specified in parameter Mask
+  * @note This register can be written only when ALRAE is reset in RTC_CR register,
+  *       or in initialization mode.
+  * @rmtoll ALRMASSR     MASKSS        LL_RTC_ALMA_SetSubSecondMask
+  * @param  RTCx RTC Instance
+  * @param  Mask Value between Min_Data=0x00 and Max_Data=0xF
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetSubSecondMask(RTC_TypeDef *RTCx, uint32_t Mask)
+{
+  MODIFY_REG(RTCx->ALRMASSR, RTC_ALRMASSR_MASKSS, Mask << RTC_ALRMASSR_MASKSS_Pos);
+}
+
+/**
+  * @brief  Get Alarm A subseconds mask
+  * @rmtoll ALRMASSR     MASKSS        LL_RTC_ALMA_GetSubSecondMask
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0xF
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetSubSecondMask(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->ALRMASSR, RTC_ALRMASSR_MASKSS) >> RTC_ALRMASSR_MASKSS_Pos);
+}
+
+/**
+  * @brief  Set Alarm A subseconds value
+  * @rmtoll ALRMASSR     SS            LL_RTC_ALMA_SetSubSecond
+  * @param  RTCx RTC Instance
+  * @param  Subsecond Value between Min_Data=0x00 and Max_Data=0x7FFF
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ALMA_SetSubSecond(RTC_TypeDef *RTCx, uint32_t Subsecond)
+{
+  MODIFY_REG(RTCx->ALRMASSR, RTC_ALRMASSR_SS, Subsecond);
+}
+
+/**
+  * @brief  Get Alarm A subseconds value
+  * @rmtoll ALRMASSR     SS            LL_RTC_ALMA_GetSubSecond
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0x7FFF
+  */
+__STATIC_INLINE uint32_t LL_RTC_ALMA_GetSubSecond(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->ALRMASSR, RTC_ALRMASSR_SS));
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_Wakeup Wakeup
+  * @{
+  */
+
+/**
+  * @brief  Enable Wakeup timer
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           WUTE          LL_RTC_WAKEUP_Enable
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_WAKEUP_Enable(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_WUTE);
+}
+
+/**
+  * @brief  Disable Wakeup timer
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           WUTE          LL_RTC_WAKEUP_Disable
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_WAKEUP_Disable(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->CR, RTC_CR_WUTE);
+}
+
+/**
+  * @brief  Check if Wakeup timer is enabled or not
+  * @rmtoll CR           WUTE          LL_RTC_WAKEUP_IsEnabled
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_WAKEUP_IsEnabled(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Select Wakeup clock
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   Bit can be written only when RTC_CR WUTE bit = 0 and RTC_ISR WUTWF bit = 1
+  * @rmtoll CR           WUCKSEL       LL_RTC_WAKEUP_SetClock
+  * @param  RTCx RTC Instance
+  * @param  WakeupClock This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_16
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_8
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_4
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_2
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_CKSPRE
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_CKSPRE_WUT
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_WAKEUP_SetClock(RTC_TypeDef *RTCx, uint32_t WakeupClock)
+{
+  MODIFY_REG(RTCx->CR, RTC_CR_WUCKSEL, WakeupClock);
+}
+
+/**
+  * @brief  Get Wakeup clock
+  * @rmtoll CR           WUCKSEL       LL_RTC_WAKEUP_GetClock
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_16
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_8
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_4
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_DIV_2
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_CKSPRE
+  *         @arg @ref LL_RTC_WAKEUPCLOCK_CKSPRE_WUT
+  */
+__STATIC_INLINE uint32_t LL_RTC_WAKEUP_GetClock(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_WUCKSEL));
+}
+
+/**
+  * @brief  Set Wakeup auto-reload value
+  * @note   Bit can be written only when WUTWF is set to 1 in RTC_ISR
+  * @rmtoll WUTR         WUT           LL_RTC_WAKEUP_SetAutoReload
+  * @param  RTCx RTC Instance
+  * @param  Value Value between Min_Data=0x00 and Max_Data=0xFFFF
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_WAKEUP_SetAutoReload(RTC_TypeDef *RTCx, uint32_t Value)
+{
+  MODIFY_REG(RTCx->WUTR, RTC_WUTR_WUT, Value);
+}
+
+/**
+  * @brief  Get Wakeup auto-reload value
+  * @rmtoll WUTR         WUT           LL_RTC_WAKEUP_GetAutoReload
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data=0xFFFF
+  */
+__STATIC_INLINE uint32_t LL_RTC_WAKEUP_GetAutoReload(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->WUTR, RTC_WUTR_WUT));
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_Backup_Registers Backup_Registers
+  * @{
+  */
+
+/**
+  * @brief  Writes a data in a specified RTC Backup data register.
+  * @rmtoll BKPxR        BKP           LL_RTC_BAK_SetRegister
+  * @param  RTCx RTC Instance
+  * @param  BackupRegister This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_BKP_DR0
+  *         @arg @ref LL_RTC_BKP_DR1
+  *         @arg @ref LL_RTC_BKP_DR2
+  *         @arg @ref LL_RTC_BKP_DR3
+  *         @arg @ref LL_RTC_BKP_DR4
+  * @param  Data Value between Min_Data=0x00 and Max_Data=0xFFFFFFFF
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_BAK_SetRegister(RTC_TypeDef *RTCx, uint32_t BackupRegister, uint32_t Data)
+{
+  uint32_t temp;
+
+  temp = (uint32_t)(&(RTCx->BKP0R));
+  temp += (BackupRegister * 4U);
+
+  /* Write the specified register */
+  *(__IO uint32_t *)temp = (uint32_t)Data;
+}
+
+/**
+  * @brief  Reads data from the specified RTC Backup data Register.
+  * @rmtoll BKPxR        BKP           LL_RTC_BAK_GetRegister
+  * @param  RTCx RTC Instance
+  * @param  BackupRegister This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_BKP_DR0
+  *         @arg @ref LL_RTC_BKP_DR1
+  *         @arg @ref LL_RTC_BKP_DR2
+  *         @arg @ref LL_RTC_BKP_DR3
+  *         @arg @ref LL_RTC_BKP_DR4
+  * @retval Value between Min_Data=0x00 and Max_Data=0xFFFFFFFF
+  */
+__STATIC_INLINE uint32_t LL_RTC_BAK_GetRegister(RTC_TypeDef *RTCx, uint32_t BackupRegister)
+{
+  uint32_t temp;
+
+  temp = (uint32_t)(&(RTCx->BKP0R));
+  temp += (BackupRegister * 4U);
+
+  /* Read the specified register */
+  return (*(__IO uint32_t *)temp);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_Calibration Calibration
+  * @{
+  */
+
+/**
+  * @brief  Set Calibration output frequency (1 Hz or 512 Hz)
+  * @note Bits are write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           COE           LL_RTC_CAL_SetOutputFreq\n
+  *         CR           COSEL         LL_RTC_CAL_SetOutputFreq
+  * @param  RTCx RTC Instance
+  * @param  Frequency This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_CALIB_OUTPUT_NONE
+  *         @arg @ref LL_RTC_CALIB_OUTPUT_1HZ
+  *         @arg @ref LL_RTC_CALIB_OUTPUT_512HZ
+  *
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_CAL_SetOutputFreq(RTC_TypeDef *RTCx, uint32_t Frequency)
+{
+  MODIFY_REG(RTCx->CR, RTC_CR_COE | RTC_CR_COSEL, Frequency);
+}
+
+/**
+  * @brief  Get Calibration output frequency (1 Hz or 512 Hz)
+  * @rmtoll CR           COE           LL_RTC_CAL_GetOutputFreq\n
+  *         CR           COSEL         LL_RTC_CAL_GetOutputFreq
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_CALIB_OUTPUT_NONE
+  *         @arg @ref LL_RTC_CALIB_OUTPUT_1HZ
+  *         @arg @ref LL_RTC_CALIB_OUTPUT_512HZ
+  *
+  */
+__STATIC_INLINE uint32_t LL_RTC_CAL_GetOutputFreq(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CR, RTC_CR_COE | RTC_CR_COSEL));
+}
+
+/**
+  * @brief  Insert or not One RTCCLK pulse every 2exp11 pulses (frequency increased by 488.5 ppm)
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   Bit can be written only when RECALPF is set to 0 in RTC_ISR
+  * @rmtoll CALR         CALP          LL_RTC_CAL_SetPulse
+  * @param  RTCx RTC Instance
+  * @param  Pulse This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_CALIB_INSERTPULSE_NONE
+  *         @arg @ref LL_RTC_CALIB_INSERTPULSE_SET
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_CAL_SetPulse(RTC_TypeDef *RTCx, uint32_t Pulse)
+{
+  MODIFY_REG(RTCx->CALR, RTC_CALR_CALP, Pulse);
+}
+
+/**
+  * @brief  Check if one RTCCLK has been inserted or not every 2exp11 pulses (frequency increased by 488.5 ppm)
+  * @rmtoll CALR         CALP          LL_RTC_CAL_IsPulseInserted
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_CAL_IsPulseInserted(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->CALR, RTC_CALR_CALP) == (RTC_CALR_CALP)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Set smooth calibration cycle period
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   Bit can be written only when RECALPF is set to 0 in RTC_ISR
+  * @rmtoll CALR         CALW8         LL_RTC_CAL_SetPeriod\n
+  *         CALR         CALW16        LL_RTC_CAL_SetPeriod
+  * @param  RTCx RTC Instance
+  * @param  Period This parameter can be one of the following values:
+  *         @arg @ref LL_RTC_CALIB_PERIOD_32SEC
+  *         @arg @ref LL_RTC_CALIB_PERIOD_16SEC
+  *         @arg @ref LL_RTC_CALIB_PERIOD_8SEC
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_CAL_SetPeriod(RTC_TypeDef *RTCx, uint32_t Period)
+{
+  MODIFY_REG(RTCx->CALR, RTC_CALR_CALW8 | RTC_CALR_CALW16, Period);
+}
+
+/**
+  * @brief  Get smooth calibration cycle period
+  * @rmtoll CALR         CALW8         LL_RTC_CAL_GetPeriod\n
+  *         CALR         CALW16        LL_RTC_CAL_GetPeriod
+  * @param  RTCx RTC Instance
+  * @retval Returned value can be one of the following values:
+  *         @arg @ref LL_RTC_CALIB_PERIOD_32SEC
+  *         @arg @ref LL_RTC_CALIB_PERIOD_16SEC
+  *         @arg @ref LL_RTC_CALIB_PERIOD_8SEC
+  */
+__STATIC_INLINE uint32_t LL_RTC_CAL_GetPeriod(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CALR, RTC_CALR_CALW8 | RTC_CALR_CALW16));
+}
+
+/**
+  * @brief  Set smooth Calibration minus
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @note   Bit can be written only when RECALPF is set to 0 in RTC_ISR
+  * @rmtoll CALR         CALM          LL_RTC_CAL_SetMinus
+  * @param  RTCx RTC Instance
+  * @param  CalibMinus Value between Min_Data=0x00 and Max_Data=0x1FF
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_CAL_SetMinus(RTC_TypeDef *RTCx, uint32_t CalibMinus)
+{
+  MODIFY_REG(RTCx->CALR, RTC_CALR_CALM, CalibMinus);
+}
+
+/**
+  * @brief  Get smooth Calibration minus
+  * @rmtoll CALR         CALM          LL_RTC_CAL_GetMinus
+  * @param  RTCx RTC Instance
+  * @retval Value between Min_Data=0x00 and Max_Data= 0x1FF
+  */
+__STATIC_INLINE uint32_t LL_RTC_CAL_GetMinus(RTC_TypeDef *RTCx)
+{
+  return (uint32_t)(READ_BIT(RTCx->CALR, RTC_CALR_CALM));
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_FLAG_Management FLAG_Management
+  * @{
+  */
+
+/**
+  * @brief  Get Recalibration pending Flag
+  * @rmtoll ISR          RECALPF       LL_RTC_IsActiveFlag_RECALP
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_RECALP(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_RECALPF) == (RTC_ISR_RECALPF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Get Wakeup timer flag
+  * @rmtoll ISR          WUTF          LL_RTC_IsActiveFlag_WUT
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_WUT(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_WUTF) == (RTC_ISR_WUTF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Get Alarm A flag
+  * @rmtoll ISR          ALRAF         LL_RTC_IsActiveFlag_ALRA
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_ALRA(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_ALRAF) == (RTC_ISR_ALRAF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Clear Wakeup timer flag
+  * @rmtoll ISR          WUTF          LL_RTC_ClearFlag_WUT
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ClearFlag_WUT(RTC_TypeDef *RTCx)
+{
+  WRITE_REG(RTCx->ISR, (~((RTC_ISR_WUTF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
+}
+
+/**
+  * @brief  Clear Alarm A flag
+  * @rmtoll ISR          ALRAF         LL_RTC_ClearFlag_ALRA
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ClearFlag_ALRA(RTC_TypeDef *RTCx)
+{
+  WRITE_REG(RTCx->ISR, (~((RTC_ISR_ALRAF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
+}
+
+/**
+  * @brief  Get Initialization flag
+  * @rmtoll ISR          INITF         LL_RTC_IsActiveFlag_INIT
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_INIT(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_INITF) == (RTC_ISR_INITF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Get Registers synchronization flag
+  * @rmtoll ISR          RSF           LL_RTC_IsActiveFlag_RS
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_RS(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_RSF) == (RTC_ISR_RSF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Clear Registers synchronization flag
+  * @rmtoll ISR          RSF           LL_RTC_ClearFlag_RS
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_ClearFlag_RS(RTC_TypeDef *RTCx)
+{
+  WRITE_REG(RTCx->ISR, (~((RTC_ISR_RSF | RTC_ISR_INIT) & 0x0000FFFFU) | (RTCx->ISR & RTC_ISR_INIT)));
+}
+
+/**
+  * @brief  Get Initialization status flag
+  * @rmtoll ISR          INITS         LL_RTC_IsActiveFlag_INITS
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_INITS(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_INITS) == (RTC_ISR_INITS)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Get Shift operation pending flag
+  * @rmtoll ISR          SHPF          LL_RTC_IsActiveFlag_SHP
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_SHP(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_SHPF) == (RTC_ISR_SHPF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Get Wakeup timer write flag
+  * @rmtoll ISR          WUTWF         LL_RTC_IsActiveFlag_WUTW
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_WUTW(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_WUTWF) == (RTC_ISR_WUTWF)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Get Alarm A write flag
+  * @rmtoll ISR          ALRAWF        LL_RTC_IsActiveFlag_ALRAW
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsActiveFlag_ALRAW(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->ISR, RTC_ISR_ALRAWF) == (RTC_ISR_ALRAWF)) ? 1UL : 0UL);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_LL_EF_IT_Management IT_Management
+  * @{
+  */
+
+/**
+  * @brief  Enable Wakeup timer interrupt
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           WUTIE         LL_RTC_EnableIT_WUT
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_EnableIT_WUT(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_WUTIE);
+}
+
+/**
+  * @brief  Disable Wakeup timer interrupt
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           WUTIE         LL_RTC_DisableIT_WUT
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DisableIT_WUT(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->CR, RTC_CR_WUTIE);
+}
+
+/**
+  * @brief  Enable Alarm A interrupt
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           ALRAIE        LL_RTC_EnableIT_ALRA
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_EnableIT_ALRA(RTC_TypeDef *RTCx)
+{
+  SET_BIT(RTCx->CR, RTC_CR_ALRAIE);
+}
+
+/**
+  * @brief  Disable Alarm A interrupt
+  * @note   Bit is write-protected. @ref LL_RTC_DisableWriteProtection function should be called before.
+  * @rmtoll CR           ALRAIE        LL_RTC_DisableIT_ALRA
+  * @param  RTCx RTC Instance
+  * @retval None
+  */
+__STATIC_INLINE void LL_RTC_DisableIT_ALRA(RTC_TypeDef *RTCx)
+{
+  CLEAR_BIT(RTCx->CR, RTC_CR_ALRAIE);
+}
+
+/**
+  * @brief  Check if  Wakeup timer interrupt is enabled or not
+  * @rmtoll CR           WUTIE         LL_RTC_IsEnabledIT_WUT
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsEnabledIT_WUT(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->CR, RTC_CR_WUTIE) == (RTC_CR_WUTIE)) ? 1UL : 0UL);
+}
+
+/**
+  * @brief  Check if  Alarm A interrupt is enabled or not
+  * @rmtoll CR           ALRAIE        LL_RTC_IsEnabledIT_ALRA
+  * @param  RTCx RTC Instance
+  * @retval State of bit (1 or 0).
+  */
+__STATIC_INLINE uint32_t LL_RTC_IsEnabledIT_ALRA(RTC_TypeDef *RTCx)
+{
+  return ((READ_BIT(RTCx->CR, RTC_CR_ALRAIE) == (RTC_CR_ALRAIE)) ? 1UL : 0UL);
+}
+
+/**
+  * @}
+  */
+
+#if defined(USE_FULL_LL_DRIVER)
+/** @defgroup RTC_LL_EF_Init Initialization and de-initialization functions
+  * @{
+  */
+
+ErrorStatus LL_RTC_DeInit(RTC_TypeDef *RTCx);
+ErrorStatus LL_RTC_Init(RTC_TypeDef *RTCx, LL_RTC_InitTypeDef *RTC_InitStruct);
+void        LL_RTC_StructInit(LL_RTC_InitTypeDef *RTC_InitStruct);
+ErrorStatus LL_RTC_TIME_Init(RTC_TypeDef *RTCx, uint32_t RTC_Format, LL_RTC_TimeTypeDef *RTC_TimeStruct);
+void        LL_RTC_TIME_StructInit(LL_RTC_TimeTypeDef *RTC_TimeStruct);
+ErrorStatus LL_RTC_DATE_Init(RTC_TypeDef *RTCx, uint32_t RTC_Format, LL_RTC_DateTypeDef *RTC_DateStruct);
+void        LL_RTC_DATE_StructInit(LL_RTC_DateTypeDef *RTC_DateStruct);
+ErrorStatus LL_RTC_ALMA_Init(RTC_TypeDef *RTCx, uint32_t RTC_Format, LL_RTC_AlarmTypeDef *RTC_AlarmStruct);
+void        LL_RTC_ALMA_StructInit(LL_RTC_AlarmTypeDef *RTC_AlarmStruct);
+ErrorStatus LL_RTC_EnterInitMode(RTC_TypeDef *RTCx);
+ErrorStatus LL_RTC_ExitInitMode(RTC_TypeDef *RTCx);
+ErrorStatus LL_RTC_WaitForSynchro(RTC_TypeDef *RTCx);
+
+/**
+  * @}
+  */
+#endif /* USE_FULL_LL_DRIVER */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+#endif /* defined(RTC) */
+
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* STM32WB0x_LL_RTC_H */
diff --git a/Drivers/STM32WB0x_HAL_Driver/Src/stm32wb0x_hal_rtc.c b/Drivers/STM32WB0x_HAL_Driver/Src/stm32wb0x_hal_rtc.c
new file mode 100644
index 0000000..9a12e5e
--- /dev/null
+++ b/Drivers/STM32WB0x_HAL_Driver/Src/stm32wb0x_hal_rtc.c
@@ -0,0 +1,1682 @@
+/**
+  ******************************************************************************
+  * @file    stm32wb0x_hal_rtc.c
+  * @author  MCD Application Team
+  * @brief   RTC HAL module driver.
+  *          This file provides firmware functions to manage the following
+  *          functionalities of the Real-Time Clock (RTC) peripheral:
+  *           + Initialization and de-initialization functions
+  *           + Calendar (Time and Date) configuration functions
+  *           + Alarm (Alarm A) configuration functions
+  *           + Peripheral Control functions
+  *           + Peripheral State functions
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * Copyright (c) 2024 STMicroelectronics.
+  * All rights reserved.
+  *
+  * This software is licensed under terms that can be found in the LICENSE file
+  * in the root directory of this software component.
+  * If no LICENSE file comes with this software, it is provided AS-IS.
+  *
+  ******************************************************************************
+  @verbatim
+  ==============================================================================
+               ##### RTC and Backup Domain Operating Condition #####
+  ==============================================================================
+  [..] The real-time clock (RTC) and the RTC backup registers can be powered
+       from the VBAT voltage when the main VDD supply is powered off.
+       To retain the content of the RTC backup registers and supply the RTC when
+       VDD is turned off, VBAT pin can be connected to an optional standby
+       voltage supplied by a battery or by another source.
+
+  [..] To allow the RTC operating even when the main digital supply (VDD) is turned
+       off, the VBAT pin powers the following blocks:
+    (#) The RTC
+    (#) The LSE oscillator
+
+  [..] When the backup domain is supplied by VDD (analog switch connected to VDD),
+       the following pins are available:
+    (#) PC14 and PC15 can be used as either GPIO or LSE pins
+    (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
+
+  [..] When the backup domain is supplied by VBAT (analog switch connected to VBAT
+       because VDD is not present), the following pins are available:
+    (#) PC14 and PC15 can be used as LSE pins only
+    (#) PC13 can be used as the RTC_AF1 pin
+
+                   ##### Backup Domain Reset #####
+  ==================================================================
+  [..] The backup domain reset sets all RTC registers and the RCC_BDCR register
+       to their reset values.
+  [..] A backup domain reset is generated when one of the following events occurs:
+    (#) Software reset, triggered by setting the BDRST bit in the
+        RCC Backup domain control register (RCC_BDCR).
+    (#) VDD or VBAT power on, if both supplies have previously been powered off.
+
+                   ##### Backup Domain Access #####
+  ==================================================================
+  [..] After reset, the backup domain (RTC registers and RTC backup data registers)
+       is protected against possible unwanted write accesses.
+  [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
+    (+) Enable the Power Controller (PWR) APB1 interface clock using the
+        __HAL_RCC_PWR_CLK_ENABLE() macro.
+    (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
+    (+) Select the RTC clock source using the __HAL_RCC_RTC_CONFIG() macro.
+    (+) Enable RTC Clock using the __HAL_RCC_RTC_ENABLE() macro.
+
+  ==============================================================================
+                        ##### How to use this driver #####
+  ==============================================================================
+  [..]
+    (+) Enable the RTC domain access (see description in the section above).
+    (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour
+        format using the HAL_RTC_Init() function.
+
+  *** Time and Date configuration ***
+  ===================================
+  [..]
+    (+) To configure the RTC Calendar (Time and Date) use the HAL_RTC_SetTime()
+        and HAL_RTC_SetDate() functions.
+    (+) To read the RTC Calendar, use the HAL_RTC_GetTime() and HAL_RTC_GetDate()
+        functions.
+    (+) To manage the RTC summer or winter time change, use the following
+        functions:
+        (++) HAL_RTC_DST_Add1Hour() or HAL_RTC_DST_Sub1Hour to add or subtract
+             1 hour from the calendar time.
+        (++) HAL_RTC_DST_SetStoreOperation() or HAL_RTC_DST_ClearStoreOperation
+             to memorize whether the time change has been performed or not.
+
+  *** Alarm configuration ***
+  ===========================
+  [..]
+    (+) To configure the RTC Alarm use the HAL_RTC_SetAlarm() function.
+        You can also configure the RTC Alarm with interrupt mode using the
+        HAL_RTC_SetAlarm_IT() function.
+    (+) To read the RTC Alarm, use the HAL_RTC_GetAlarm() function.
+
+                  ##### RTC and low power modes #####
+  ==================================================================
+  [..] The MCU can be woken up from a low power mode by an RTC alternate
+       function.
+  [..] The RTC alternate functions are the RTC alarm (Alarm A),
+       and RTC wakeup.
+       These RTC alternate functions can wake up the system from the Stop and
+       Standby low power modes.
+  [..] The system can also wake up from low power modes without depending
+       on an external interrupt (Auto-wakeup mode), by using the RTC alarm
+       or the RTC wakeup events.
+  [..] The RTC provides a programmable time base for waking up from the
+       Stop or Standby mode at regular intervals.
+       Wakeup from STOP and STANDBY modes is possible only when the RTC clock
+       source is LSE or LSI.
+
+  *** Callback registration ***
+  =============================================
+  [..]
+  When the compilation define USE_HAL_RTC_REGISTER_CALLBACKS is set to 0 or
+  not defined, the callback registration feature is not available and all
+  callbacks are set to the corresponding weak functions.
+  This is the recommended configuration in order to optimize memory/code
+  consumption footprint/performances.
+  [..]
+  The compilation define  USE_HAL_RTC_REGISTER_CALLBACKS when set to 1
+  allows the user to configure dynamically the driver callbacks.
+  Use Function HAL_RTC_RegisterCallback() to register an interrupt callback.
+  [..]
+  Function HAL_RTC_RegisterCallback() allows to register following callbacks:
+    (+) AlarmAEventCallback          : RTC Alarm A Event callback.
+    (+) WakeUpTimerEventCallback     : RTC WakeUpTimer Event callback.
+    (+) MspInitCallback              : RTC MspInit callback.
+    (+) MspDeInitCallback            : RTC MspDeInit callback.
+  [..]
+  This function takes as parameters the HAL peripheral handle, the Callback ID
+  and a pointer to the user callback function.
+  [..]
+  Use function HAL_RTC_UnRegisterCallback() to reset a callback to the default
+  weak function.
+  HAL_RTC_UnRegisterCallback() takes as parameters the HAL peripheral handle,
+  and the Callback ID.
+  This function allows to reset following callbacks:
+    (+) AlarmAEventCallback          : RTC Alarm A Event callback.
+    (+) WakeUpTimerEventCallback     : RTC WakeUpTimer Event callback.
+    (+) MspInitCallback              : RTC MspInit callback.
+    (+) MspDeInitCallback            : RTC MspDeInit callback.
+  [..]
+  By default, after the HAL_RTC_Init() and when the state is HAL_RTC_STATE_RESET,
+  all callbacks are set to the corresponding weak functions:
+  examples AlarmAEventCallback(), TimeStampEventCallback().
+  Exception done for MspInit() and MspDeInit() callbacks that are reset to the
+  legacy weak function in the HAL_RTC_Init()/HAL_RTC_DeInit() only when these
+  callbacks are null (not registered beforehand).
+  If not, MspInit() or MspDeInit() are not null, HAL_RTC_Init()/HAL_RTC_DeInit()
+  keep and use the user MspInit()/MspDeInit() callbacks (registered beforehand).
+  [..]
+  Callbacks can be registered/unregistered in HAL_RTC_STATE_READY state only.
+  Exception done for MspInit() and MspDeInit() that can be registered/unregistered
+  in HAL_RTC_STATE_READY or HAL_RTC_STATE_RESET state.
+  Thus registered (user) MspInit()/MspDeInit() callbacks can be used during the
+  Init/DeInit.
+  In that case first register the MspInit()/MspDeInit() user callbacks using
+  HAL_RTC_RegisterCallback() before calling HAL_RTC_DeInit() or HAL_RTC_Init()
+  functions.
+
+  @endverbatim
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32wb0x_hal.h"
+
+/** @addtogroup STM32WB0x_HAL_Driver
+  * @{
+  */
+
+/** @defgroup RTC RTC
+  * @brief    RTC HAL module driver
+  * @{
+  */
+
+#ifdef HAL_RTC_MODULE_ENABLED
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+/** @defgroup RTC_Exported_Functions RTC Exported Functions
+  * @{
+  */
+
+/** @defgroup RTC_Exported_Functions_Group1 Initialization and de-initialization functions
+  * @brief    Initialization and Configuration functions
+  *
+@verbatim
+ ===============================================================================
+              ##### Initialization and de-initialization functions #####
+ ===============================================================================
+   [..] This section provides functions allowing to initialize and configure the
+         RTC Prescaler (Synchronous and Asynchronous), RTC Hour format, disable
+         RTC registers Write protection, enter and exit the RTC initialization mode,
+         RTC registers synchronization check and reference clock detection enable.
+         (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base.
+             It is split into 2 programmable prescalers to minimize power consumption.
+             (++) A 7-bit asynchronous prescaler and a 15-bit synchronous prescaler.
+             (++) When both prescalers are used, it is recommended to configure the
+                 asynchronous prescaler to a high value to minimize power consumption.
+         (#) All RTC registers are Write protected. Writing to the RTC registers
+             is enabled by writing a key into the Write Protection register, RTC_WPR.
+         (#) To configure the RTC Calendar, user application should enter
+             initialization mode. In this mode, the calendar counter is stopped
+             and its value can be updated. When the initialization sequence is
+             complete, the calendar restarts counting after 4 RTCCLK cycles.
+         (#) To read the calendar through the shadow registers after Calendar
+             initialization, calendar update or after wakeup from low power modes
+             the software must first clear the RSF flag. The software must then
+             wait until it is set again before reading the calendar, which means
+             that the calendar registers have been correctly copied into the
+             RTC_TR and RTC_DR shadow registers. The HAL_RTC_WaitForSynchro() function
+             implements the above software sequence (RSF clear and RSF check).
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Initializes the RTC peripheral
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
+{
+  HAL_StatusTypeDef status = HAL_ERROR;
+
+  /* Check RTC handler validity */
+  if (hrtc == NULL)
+  {
+    return HAL_ERROR;
+  }
+
+  /* Check the parameters */
+  assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
+  assert_param(IS_RTC_HOUR_FORMAT(hrtc->Init.HourFormat));
+  assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
+  assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
+  assert_param(IS_RTC_OUTPUT(hrtc->Init.OutPut));
+  assert_param(IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
+
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+  if (hrtc->State == HAL_RTC_STATE_RESET)
+  {
+    /* Allocate lock resource and initialize it */
+    hrtc->Lock = HAL_UNLOCKED;
+
+    hrtc->AlarmAEventCallback          =  HAL_RTC_AlarmAEventCallback;        /* Legacy weak AlarmAEventCallback      */
+    hrtc->WakeUpTimerEventCallback     =  HAL_RTCEx_WakeUpTimerEventCallback; /* Legacy weak WakeUpTimerEventCallback */
+
+    if (hrtc->MspInitCallback == NULL)
+    {
+      hrtc->MspInitCallback = HAL_RTC_MspInit;
+    }
+    /* Init the low level hardware */
+    hrtc->MspInitCallback(hrtc);
+
+    if (hrtc->MspDeInitCallback == NULL)
+    {
+      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
+    }
+  }
+#else /* USE_HAL_RTC_REGISTER_CALLBACKS */
+  if (hrtc->State == HAL_RTC_STATE_RESET)
+  {
+    /* Allocate lock resource and initialize it */
+    hrtc->Lock = HAL_UNLOCKED;
+
+    /* Initialize RTC MSP */
+    HAL_RTC_MspInit(hrtc);
+  }
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+
+  /* Set RTC state */
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Check whether the calendar needs to be initialized */
+  if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
+  {
+    /* Disable the write protection for RTC registers */
+    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+    /* Enter Initialization mode */
+    status = RTC_EnterInitMode(hrtc);
+
+    if (status == HAL_OK)
+    {
+      /* Clear RTC_CR FMT, OSEL and POL Bits */
+      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
+      /* Set RTC_CR register */
+      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
+
+      /* Configure the RTC PRER */
+      hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
+      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
+
+      /* Exit Initialization mode */
+      status = RTC_ExitInitMode(hrtc);
+    }
+
+    /* Enable the write protection for RTC registers */
+    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+  }
+  else
+  {
+    /* The calendar is already initialized */
+    status = HAL_OK;
+  }
+
+  if (status == HAL_OK)
+  {
+    hrtc->State = HAL_RTC_STATE_READY;
+  }
+
+  return status;
+}
+
+/**
+  * @brief  DeInitializes the RTC peripheral
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @note   This function does not reset the RTC Backup Data registers.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
+{
+  HAL_StatusTypeDef status = HAL_ERROR;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
+
+  /* Set RTC state */
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Enter Initialization mode */
+  status = RTC_EnterInitMode(hrtc);
+
+  if (status == HAL_OK)
+  {
+    /* Reset RTC registers */
+    hrtc->Instance->TR = 0x00000000U;
+    hrtc->Instance->DR = (RTC_DR_WDU_0 | RTC_DR_MU_0 | RTC_DR_DU_0);
+    hrtc->Instance->CR  &= 0x00000000U;
+    hrtc->Instance->WUTR = RTC_WUTR_WUT;
+    hrtc->Instance->PRER = (uint32_t)(RTC_PRER_PREDIV_A | 0x000000FFU);
+    hrtc->Instance->ALRMAR   = 0x00000000U;
+    hrtc->Instance->CALR     = 0x00000000U;
+    hrtc->Instance->SHIFTR   = 0x00000000U;
+    hrtc->Instance->ALRMASSR = 0x00000000U;
+
+    /* Exit Initialization mode */
+    status = RTC_ExitInitMode(hrtc);
+  }
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  if (status == HAL_OK)
+  {
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+    if (hrtc->MspDeInitCallback == NULL)
+    {
+      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
+    }
+
+    /* DeInit the low level hardware: CLOCK, NVIC.*/
+    hrtc->MspDeInitCallback(hrtc);
+#else /* USE_HAL_RTC_REGISTER_CALLBACKS */
+    /* De-Initialize RTC MSP */
+    HAL_RTC_MspDeInit(hrtc);
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+
+    hrtc->State = HAL_RTC_STATE_RESET;
+  }
+
+  /* Release Lock */
+  __HAL_UNLOCK(hrtc);
+
+  return status;
+}
+
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+/**
+  * @brief  Registers a User RTC Callback
+  *         To be used instead of the weak predefined callback
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  CallbackID ID of the callback to be registered
+  *         This parameter can be one of the following values:
+  *          @arg @ref HAL_RTC_ALARM_A_EVENT_CB_ID          Alarm A Event Callback ID
+  *          @arg @ref HAL_RTC_WAKEUPTIMER_EVENT_CB_ID      Wakeup Timer Event Callback ID
+  *          @arg @ref HAL_RTC_MSPINIT_CB_ID                MSP Init callback ID
+  *          @arg @ref HAL_RTC_MSPDEINIT_CB_ID              MSP DeInit callback ID
+  * @param  pCallback pointer to the Callback function
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_RegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID, pRTC_CallbackTypeDef pCallback)
+{
+  HAL_StatusTypeDef status = HAL_OK;
+
+  if (pCallback == NULL)
+  {
+    return HAL_ERROR;
+  }
+
+  /* Process locked */
+  __HAL_LOCK(hrtc);
+
+  if (HAL_RTC_STATE_READY == hrtc->State)
+  {
+    switch (CallbackID)
+    {
+      case HAL_RTC_ALARM_A_EVENT_CB_ID :
+        hrtc->AlarmAEventCallback = pCallback;
+        break;
+
+      case HAL_RTC_WAKEUPTIMER_EVENT_CB_ID :
+        hrtc->WakeUpTimerEventCallback = pCallback;
+        break;
+
+      case HAL_RTC_MSPINIT_CB_ID :
+        hrtc->MspInitCallback = pCallback;
+        break;
+
+      case HAL_RTC_MSPDEINIT_CB_ID :
+        hrtc->MspDeInitCallback = pCallback;
+        break;
+
+      default :
+        /* Return error status */
+        status =  HAL_ERROR;
+        break;
+    }
+  }
+  else if (HAL_RTC_STATE_RESET == hrtc->State)
+  {
+    switch (CallbackID)
+    {
+      case HAL_RTC_MSPINIT_CB_ID :
+        hrtc->MspInitCallback = pCallback;
+        break;
+
+      case HAL_RTC_MSPDEINIT_CB_ID :
+        hrtc->MspDeInitCallback = pCallback;
+        break;
+
+      default :
+        /* Return error status */
+        status =  HAL_ERROR;
+        break;
+    }
+  }
+  else
+  {
+    /* Return error status */
+    status =  HAL_ERROR;
+  }
+
+  /* Release Lock */
+  __HAL_UNLOCK(hrtc);
+
+  return status;
+}
+
+/**
+  * @brief  Unregisters an RTC Callback
+  *         RTC callback is redirected to the weak predefined callback
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  CallbackID ID of the callback to be unregistered
+  *         This parameter can be one of the following values:
+  *          @arg @ref HAL_RTC_ALARM_A_EVENT_CB_ID          Alarm A Event Callback ID
+  *          @arg @ref HAL_RTC_WAKEUPTIMER_EVENT_CB_ID      Wakeup Timer Event Callback ID
+  *          @arg @ref HAL_RTC_MSPINIT_CB_ID                MSP Init callback ID
+  *          @arg @ref HAL_RTC_MSPDEINIT_CB_ID              MSP DeInit callback ID
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_UnRegisterCallback(RTC_HandleTypeDef *hrtc, HAL_RTC_CallbackIDTypeDef CallbackID)
+{
+  HAL_StatusTypeDef status = HAL_OK;
+
+  /* Process locked */
+  __HAL_LOCK(hrtc);
+
+  if (HAL_RTC_STATE_READY == hrtc->State)
+  {
+    switch (CallbackID)
+    {
+      case HAL_RTC_ALARM_A_EVENT_CB_ID :
+        hrtc->AlarmAEventCallback = HAL_RTC_AlarmAEventCallback;             /* Legacy weak AlarmAEventCallback    */
+        break;
+
+      case HAL_RTC_WAKEUPTIMER_EVENT_CB_ID :
+        hrtc->WakeUpTimerEventCallback = HAL_RTCEx_WakeUpTimerEventCallback; /* Legacy weak WakeUpTimerEventCallback */
+        break;
+
+      case HAL_RTC_MSPINIT_CB_ID :
+        hrtc->MspInitCallback = HAL_RTC_MspInit;
+        break;
+
+      case HAL_RTC_MSPDEINIT_CB_ID :
+        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
+        break;
+
+      default :
+        /* Return error status */
+        status =  HAL_ERROR;
+        break;
+    }
+  }
+  else if (HAL_RTC_STATE_RESET == hrtc->State)
+  {
+    switch (CallbackID)
+    {
+      case HAL_RTC_MSPINIT_CB_ID :
+        hrtc->MspInitCallback = HAL_RTC_MspInit;
+        break;
+
+      case HAL_RTC_MSPDEINIT_CB_ID :
+        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
+        break;
+
+      default :
+        /* Return error status */
+        status =  HAL_ERROR;
+        break;
+    }
+  }
+  else
+  {
+    /* Return error status */
+    status =  HAL_ERROR;
+  }
+
+  /* Release Lock */
+  __HAL_UNLOCK(hrtc);
+
+  return status;
+}
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+
+/**
+  * @brief  Initializes the RTC MSP.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+__weak void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
+{
+  /* Prevent unused argument(s) compilation warning */
+  UNUSED(hrtc);
+
+  /* NOTE: This function should not be modified, when the callback is needed,
+           the HAL_RTC_MspInit could be implemented in the user file
+   */
+}
+
+/**
+  * @brief  DeInitializes the RTC MSP.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+__weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
+{
+  /* Prevent unused argument(s) compilation warning */
+  UNUSED(hrtc);
+
+  /* NOTE: This function should not be modified, when the callback is needed,
+           the HAL_RTC_MspDeInit could be implemented in the user file
+   */
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Functions_Group2 RTC Time and Date functions
+  * @brief    RTC Time and Date functions
+  *
+@verbatim
+ ===============================================================================
+                 ##### RTC Time and Date functions #####
+ ===============================================================================
+
+ [..] This section provides functions allowing to configure Time and Date features
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Sets RTC current time.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sTime Pointer to Time structure
+  * @note   DayLightSaving and StoreOperation interfaces are deprecated.
+  *         To manage Daylight Saving Time, please use HAL_RTC_DST_xxx functions.
+  * @param  Format Specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_FORMAT_BIN: Binary data format
+  *            @arg RTC_FORMAT_BCD: BCD data format
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
+{
+  uint32_t tmpreg = 0U;
+  HAL_StatusTypeDef status;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
+  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  if (Format == RTC_FORMAT_BIN)
+  {
+    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
+    {
+      assert_param(IS_RTC_HOUR12(sTime->Hours));
+      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
+    }
+    else
+    {
+      sTime->TimeFormat = 0x00U;
+      assert_param(IS_RTC_HOUR24(sTime->Hours));
+    }
+    assert_param(IS_RTC_MINUTES(sTime->Minutes));
+    assert_param(IS_RTC_SECONDS(sTime->Seconds));
+
+    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
+                        ( (uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
+                        ( (uint32_t)RTC_ByteToBcd2(sTime->Seconds))                   | \
+                        (((uint32_t)sTime->TimeFormat)             << RTC_TR_PM_Pos));
+  }
+  else
+  {
+    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
+    {
+      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
+      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
+    }
+    else
+    {
+      sTime->TimeFormat = 0x00U;
+      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
+    }
+    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
+    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
+    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
+              ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
+              ((uint32_t) sTime->Seconds)                       | \
+              ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
+  }
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Enter Initialization mode */
+  status = RTC_EnterInitMode(hrtc);
+
+  if (status == HAL_OK)
+  {
+    /* Set the RTC_TR register */
+    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
+
+    /* Clear the bits to be configured (Deprecated. Use HAL_RTC_DST_xxx functions instead) */
+    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BKP;
+
+    /* Configure the RTC_CR register (Deprecated. Use HAL_RTC_DST_xxx functions instead) */
+    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
+
+    /* Exit Initialization mode */
+    status = RTC_ExitInitMode(hrtc);
+  }
+
+  if (status == HAL_OK)
+  {
+    hrtc->State = HAL_RTC_STATE_READY;
+  }
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return status;
+}
+
+/**
+  * @brief  Gets RTC current time.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sTime Pointer to Time structure
+  * @param  Format Specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_FORMAT_BIN: Binary data format
+  *            @arg RTC_FORMAT_BCD: BCD data format
+  * @note  You can use SubSeconds and SecondFraction (sTime structure fields
+  *        returned) to convert SubSeconds value in second fraction ratio with
+  *        time unit following generic formula:
+  *        Second fraction ratio * time_unit =
+  *           [(SecondFraction - SubSeconds) / (SecondFraction + 1)] * time_unit
+  *        This conversion can be performed only if no shift operation is pending
+  *        (ie. SHFP=0) when PREDIV_S >= SS
+  * @note  You must call HAL_RTC_GetDate() after HAL_RTC_GetTime() to unlock the
+  *        values in the higher-order calendar shadow registers to ensure
+  *        consistency between the time and date values.
+  *        Reading RTC current time locks the values in calendar shadow registers
+  *        until current date is read to ensure consistency between the time and
+  *        date values.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
+{
+  uint32_t tmpreg = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+
+  /* Get subseconds value from the corresponding register */
+  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
+
+  /* Get SecondFraction structure field from the corresponding register field*/
+  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
+
+  /* Get the TR register */
+  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
+
+  /* Fill the structure fields with the read parameters */
+  sTime->Hours      = (uint8_t)((tmpreg & (RTC_TR_HT  | RTC_TR_HU))  >> RTC_TR_HU_Pos);
+  sTime->Minutes    = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
+  sTime->Seconds    = (uint8_t)( tmpreg & (RTC_TR_ST  | RTC_TR_SU));
+  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM))               >> RTC_TR_PM_Pos);
+
+  /* Check the input parameters format */
+  if (Format == RTC_FORMAT_BIN)
+  {
+    /* Convert the time structure parameters to Binary format */
+    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
+    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
+    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
+  }
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Sets RTC current date.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sDate Pointer to date structure
+  * @param  Format specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_FORMAT_BIN: Binary data format
+  *            @arg RTC_FORMAT_BCD: BCD data format
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
+{
+  uint32_t datetmpreg = 0U;
+  HAL_StatusTypeDef status;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
+  {
+    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
+  }
+
+  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));
+
+  if (Format == RTC_FORMAT_BIN)
+  {
+    assert_param(IS_RTC_YEAR(sDate->Year));
+    assert_param(IS_RTC_MONTH(sDate->Month));
+    assert_param(IS_RTC_DATE(sDate->Date));
+
+    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
+                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
+                  ((uint32_t)RTC_ByteToBcd2(sDate->Date))                   | \
+                  ((uint32_t)sDate->WeekDay               << RTC_DR_WDU_Pos));
+  }
+  else
+  {
+    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
+    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
+    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
+
+    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
+                  (((uint32_t)sDate->Month)   << RTC_DR_MU_Pos) | \
+                  ((uint32_t) sDate->Date)                      | \
+                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
+  }
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Enter Initialization mode */
+  status = RTC_EnterInitMode(hrtc);
+
+  if (status == HAL_OK)
+  {
+    /* Set the RTC_DR register */
+    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
+
+    /* Exit Initialization mode */
+    status = RTC_ExitInitMode(hrtc);
+  }
+
+  if (status == HAL_OK)
+  {
+    hrtc->State = HAL_RTC_STATE_READY;
+  }
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return status;
+}
+
+/**
+  * @brief  Gets RTC current date.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sDate Pointer to Date structure
+  * @param  Format Specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *            @arg RTC_FORMAT_BIN:  Binary data format
+  *            @arg RTC_FORMAT_BCD:  BCD data format
+  * @note  You must call HAL_RTC_GetDate() after HAL_RTC_GetTime() to unlock the
+  *        values in the higher-order calendar shadow registers to ensure
+  *        consistency between the time and date values.
+  *        Reading RTC current time locks the values in calendar shadow registers
+  *        until current date is read to ensure consistency between the time and
+  *        date values.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
+{
+  uint32_t datetmpreg = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+
+  /* Get the DR register */
+  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
+
+  /* Fill the structure fields with the read parameters */
+  sDate->Year    = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
+  sDate->Month   = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
+  sDate->Date    = (uint8_t) (datetmpreg & (RTC_DR_DT | RTC_DR_DU));
+  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU))            >> RTC_DR_WDU_Pos);
+
+  /* Check the input parameters format */
+  if (Format == RTC_FORMAT_BIN)
+  {
+    /* Convert the date structure parameters to Binary format */
+    sDate->Year  = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
+    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
+    sDate->Date  = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
+  }
+  return HAL_OK;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Functions_Group3 RTC Alarm functions
+  * @brief    RTC Alarm functions
+  *
+@verbatim
+ ===============================================================================
+                 ##### RTC Alarm functions #####
+ ===============================================================================
+
+ [..] This section provides functions allowing to configure Alarm feature
+
+@endverbatim
+  * @{
+  */
+/**
+  * @brief  Sets the specified RTC Alarm.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sAlarm Pointer to Alarm structure
+  * @param  Format Specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *             @arg RTC_FORMAT_BIN: Binary data format
+  *             @arg RTC_FORMAT_BCD: BCD data format
+  * @note   The Alarm register can only be written when the corresponding Alarm
+  *         is disabled (Use the HAL_RTC_DeactivateAlarm()).
+  * @note   The HAL_RTC_SetTime() must be called before enabling the Alarm feature.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
+{
+  uint32_t tickstart = 0U;
+  uint32_t tmpreg = 0U;
+  uint32_t subsecondtmpreg = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+  assert_param(IS_RTC_ALARM(sAlarm->Alarm));
+  assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
+  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
+  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
+  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  /* Change RTC state to BUSY */
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Check the data format (binary or BCD) and store the Alarm time and date
+     configuration accordingly */
+  if (Format == RTC_FORMAT_BIN)
+  {
+    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
+    {
+      assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
+      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
+    }
+    else
+    {
+      sAlarm->AlarmTime.TimeFormat = 0x00U;
+      assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
+    }
+    assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
+    assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
+
+    if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
+    }
+    else
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
+    }
+
+    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
+              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
+              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds))                       | \
+              ((uint32_t)(sAlarm->AlarmTime.TimeFormat)            << RTC_TR_PM_Pos)      | \
+              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay)  << RTC_ALRMAR_DU_Pos)  | \
+              ((uint32_t)sAlarm->AlarmDateWeekDaySel)                                     | \
+              ((uint32_t)sAlarm->AlarmMask));
+  }
+  else
+  {
+    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
+    {
+      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
+      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
+    }
+    else
+    {
+      sAlarm->AlarmTime.TimeFormat = 0x00U;
+      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
+    }
+
+    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
+    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
+
+    if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
+    }
+    else
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
+    }
+
+    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
+              ((uint32_t)(sAlarm->AlarmTime.Minutes)    << RTC_ALRMAR_MNU_Pos) | \
+              ((uint32_t) sAlarm->AlarmTime.Seconds)                           | \
+              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_TR_PM_Pos)      | \
+              ((uint32_t)(sAlarm->AlarmDateWeekDay)     << RTC_ALRMAR_DU_Pos)  | \
+              ((uint32_t) sAlarm->AlarmDateWeekDaySel)                         | \
+              ((uint32_t) sAlarm->AlarmMask));
+  }
+
+  /* Store the Alarm subseconds configuration */
+  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | \
+                               (uint32_t)(sAlarm->AlarmSubSecondMask));
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+    /* Disable the Alarm A */
+    __HAL_RTC_ALARMA_DISABLE(hrtc);
+
+    /* In case interrupt mode is used, the interrupt source must be disabled */
+    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
+
+    /* Clear the Alarm flag */
+    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
+
+    /* Get tick */
+    tickstart = HAL_GetTick();
+
+    /* Wait till RTC ALRAWF flag is set and if timeout is reached exit */
+    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
+    {
+      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+      {
+        /* Enable the write protection for RTC registers */
+        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+        /* Process Unlocked */
+        __HAL_UNLOCK(hrtc);
+
+        return HAL_TIMEOUT;
+      }
+    }
+
+    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
+    /* Configure the Alarm A Subseconds register */
+    hrtc->Instance->ALRMASSR = subsecondtmpreg;
+    /* Configure the Alarm state: Enable Alarm */
+    __HAL_RTC_ALARMA_ENABLE(hrtc);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state back to READY */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Sets the specified RTC Alarm with Interrupt.
+  * @note   The application must ensure that the RTC interrupt line is configured via HAL SYSCFG services and the PWR_WAKEUP_PIN_RTC bit is set.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sAlarm Pointer to Alarm structure
+  * @param  Format Specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *             @arg RTC_FORMAT_BIN: Binary data format
+  *             @arg RTC_FORMAT_BCD: BCD data format
+  * @note   The Alarm register can only be written when the corresponding Alarm
+  *         is disabled (Use the HAL_RTC_DeactivateAlarm()).
+  * @note   The HAL_RTC_SetTime() must be called before enabling the Alarm feature.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
+{
+  __IO uint32_t count  = RTC_TIMEOUT_VALUE * (SystemCoreClock / 32U / 1000U);
+       uint32_t tmpreg = 0U;
+       uint32_t subsecondtmpreg = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+  assert_param(IS_RTC_ALARM(sAlarm->Alarm));
+  assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
+  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
+  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
+  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  /* Change RTC state to BUSY */
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Check the data format (binary or BCD) and store the Alarm time and date
+     configuration accordingly */
+  if (Format == RTC_FORMAT_BIN)
+  {
+    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
+    {
+      assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
+      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
+    }
+    else
+    {
+      sAlarm->AlarmTime.TimeFormat = 0x00U;
+      assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
+    }
+    assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
+    assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
+
+    if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
+    }
+    else
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
+    }
+
+    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours)   << RTC_ALRMAR_HU_Pos)  | \
+              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
+              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds))                       | \
+              ((uint32_t)(sAlarm->AlarmTime.TimeFormat)            << RTC_TR_PM_Pos)      | \
+              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay)  << RTC_ALRMAR_DU_Pos)  | \
+              ((uint32_t)sAlarm->AlarmDateWeekDaySel)                                     | \
+              ((uint32_t)sAlarm->AlarmMask));
+  }
+  else
+  {
+    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
+    {
+      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
+      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
+    }
+    else
+    {
+      sAlarm->AlarmTime.TimeFormat = 0x00U;
+      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
+    }
+
+    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
+    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
+
+    if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
+    }
+    else
+    {
+      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
+    }
+
+    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours)      << RTC_ALRMAR_HU_Pos)  | \
+              ((uint32_t)(sAlarm->AlarmTime.Minutes)    << RTC_ALRMAR_MNU_Pos) | \
+              ((uint32_t) sAlarm->AlarmTime.Seconds)                           | \
+              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_TR_PM_Pos)      | \
+              ((uint32_t)(sAlarm->AlarmDateWeekDay)     << RTC_ALRMAR_DU_Pos)  | \
+              ((uint32_t) sAlarm->AlarmDateWeekDaySel)                         | \
+              ((uint32_t) sAlarm->AlarmMask));
+  }
+
+  /* Store the Alarm subseconds configuration */
+  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | \
+                               (uint32_t)(sAlarm->AlarmSubSecondMask));
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+    /* Disable the Alarm A */
+    __HAL_RTC_ALARMA_DISABLE(hrtc);
+
+    /* Clear the Alarm flag */
+    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
+
+    /* Wait till RTC ALRAWF flag is set and if timeout is reached exit */
+    do
+    {
+      count = count - 1U;
+      if (count == 0U)
+      {
+        /* Enable the write protection for RTC registers */
+        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+        /* Process Unlocked */
+        __HAL_UNLOCK(hrtc);
+
+        return HAL_TIMEOUT;
+      }
+    } while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U);
+
+    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
+    /* Configure the Alarm A Subseconds register */
+    hrtc->Instance->ALRMASSR = subsecondtmpreg;
+    /* Configure the Alarm state: Enable Alarm */
+    __HAL_RTC_ALARMA_ENABLE(hrtc);
+    /* Configure the Alarm interrupt */
+    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state back to READY */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Deactivates the specified RTC Alarm.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  Alarm Specifies the Alarm.
+  *          This parameter can be:
+  *            @arg RTC_ALARM_A: Alarm A
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
+{
+  uint32_t tickstart = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_ALARM(Alarm));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+    /* Disable Alarm A */
+    __HAL_RTC_ALARMA_DISABLE(hrtc);
+
+    /* In case interrupt mode is used, the interrupt source must be disabled */
+    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
+
+    /* Get tick */
+    tickstart = HAL_GetTick();
+
+    /* Wait till RTC ALRxWF flag is set and if timeout is reached exit */
+    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
+    {
+      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+      {
+        /* Enable the write protection for RTC registers */
+        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+        /* Process Unlocked */
+        __HAL_UNLOCK(hrtc);
+
+        return HAL_TIMEOUT;
+      }
+    }
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Gets the RTC Alarm value and masks.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  sAlarm Pointer to Date structure
+  * @param  Alarm Specifies the Alarm.
+  *          This parameter can be:
+  *            @arg RTC_ALARM_A: Alarm A
+  * @param  Format Specifies the format of the entered parameters.
+  *          This parameter can be one of the following values:
+  *             @arg RTC_FORMAT_BIN: Binary data format
+  *             @arg RTC_FORMAT_BCD: BCD data format
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
+{
+  uint32_t tmpreg = 0U;
+  uint32_t subsecondtmpreg = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_FORMAT(Format));
+  assert_param(IS_RTC_ALARM(Alarm));
+
+  sAlarm->Alarm = RTC_ALARM_A;
+
+  tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
+  subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR) & RTC_ALRMASSR_SS);
+
+  /* Fill the structure with the read parameters */
+  sAlarm->AlarmTime.Hours      = (uint8_t) ((tmpreg & (RTC_ALRMAR_HT  | RTC_ALRMAR_HU))  >> RTC_ALRMAR_HU_Pos);
+  sAlarm->AlarmTime.Minutes    = (uint8_t) ((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> RTC_ALRMAR_MNU_Pos);
+  sAlarm->AlarmTime.Seconds    = (uint8_t) ( tmpreg & (RTC_ALRMAR_ST  | RTC_ALRMAR_SU));
+  sAlarm->AlarmTime.TimeFormat = (uint8_t) ((tmpreg & RTC_ALRMAR_PM)                     >> RTC_TR_PM_Pos);
+  sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
+  sAlarm->AlarmDateWeekDay     = (uint8_t) ((tmpreg & (RTC_ALRMAR_DT  | RTC_ALRMAR_DU))  >> RTC_ALRMAR_DU_Pos);
+  sAlarm->AlarmDateWeekDaySel  = (uint32_t) (tmpreg & RTC_ALRMAR_WDSEL);
+  sAlarm->AlarmMask            = (uint32_t) (tmpreg & RTC_ALARMMASK_ALL);
+
+  if (Format == RTC_FORMAT_BIN)
+  {
+    sAlarm->AlarmTime.Hours   = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
+    sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
+    sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
+    sAlarm->AlarmDateWeekDay  = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
+  }
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Handles Alarm interrupt request.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
+{
+  /* Get the Alarm A interrupt source enable status */
+  if (__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != 0U)
+  {
+    /* Get the pending status of the Alarm A Interrupt */
+    if (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != 0U)
+    {
+      /* Clear the Alarm A interrupt pending bit */
+      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
+
+      /* Alarm A callback */
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+      hrtc->AlarmAEventCallback(hrtc);
+#else
+      HAL_RTC_AlarmAEventCallback(hrtc);
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+    }
+  }
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+}
+
+/**
+  * @brief  Alarm A callback.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+__weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
+{
+  /* Prevent unused argument(s) compilation warning */
+  UNUSED(hrtc);
+
+  /* NOTE: This function should not be modified, when the callback is needed,
+           the HAL_RTC_AlarmAEventCallback could be implemented in the user file
+   */
+}
+
+/**
+  * @brief  Handles Alarm A Polling request.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  Timeout Timeout duration
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
+{
+  uint32_t tickstart = 0U;
+
+  /* Get tick */
+  tickstart = HAL_GetTick();
+
+  /* Wait till RTC ALRAF flag is set and if timeout is reached exit */
+  while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == 0U)
+  {
+    if (Timeout != HAL_MAX_DELAY)
+    {
+      if ((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
+      {
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+        return HAL_TIMEOUT;
+      }
+    }
+  }
+
+  /* Clear the Alarm flag */
+  __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  return HAL_OK;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Functions_Group4 Peripheral Control functions
+  * @brief    Peripheral Control functions
+  *
+@verbatim
+ ===============================================================================
+                     ##### Peripheral Control functions #####
+ ===============================================================================
+    [..]
+    This subsection provides functions allowing to
+      (+) Wait for RTC Time and Date Synchronization
+      (+) Manage RTC Summer or Winter time change
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are
+  *         synchronized with RTC APB clock.
+  * @note   The RTC Resynchronization mode is write protected, use the
+  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
+  * @note   To read the calendar through the shadow registers after Calendar
+  *         initialization, calendar update or after wakeup from low power modes
+  *         the software must first clear the RSF flag.
+  *         The software must then wait until it is set again before reading
+  *         the calendar, which means that the calendar registers have been
+  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
+{
+  uint32_t tickstart = 0U;
+
+  /* Clear RSF flag, keep reserved bits at reset values (setting other flags has no effect) */
+  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
+
+  /* Get tick */
+  tickstart = HAL_GetTick();
+
+  /* Wait the registers to be synchronised */
+  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
+  {
+    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+    {
+      return HAL_TIMEOUT;
+    }
+  }
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Daylight Saving Time, adds one hour to the calendar in one
+  *         single operation without going through the initialization procedure.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+void HAL_RTC_DST_Add1Hour(RTC_HandleTypeDef *hrtc)
+{
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+  SET_BIT(hrtc->Instance->CR, RTC_CR_ADD1H);
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+}
+
+/**
+  * @brief  Daylight Saving Time, subtracts one hour from the calendar in one
+  *         single operation without going through the initialization procedure.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+void HAL_RTC_DST_Sub1Hour(RTC_HandleTypeDef *hrtc)
+{
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+  SET_BIT(hrtc->Instance->CR, RTC_CR_SUB1H);
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+}
+
+/**
+  * @brief  Daylight Saving Time, sets the store operation bit.
+  * @note   It can be used by the software in order to memorize the DST status.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+void HAL_RTC_DST_SetStoreOperation(RTC_HandleTypeDef *hrtc)
+{
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+  SET_BIT(hrtc->Instance->CR, RTC_CR_BKP);
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+}
+
+/**
+  * @brief  Daylight Saving Time, clears the store operation bit.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+void HAL_RTC_DST_ClearStoreOperation(RTC_HandleTypeDef *hrtc)
+{
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+  CLEAR_BIT(hrtc->Instance->CR, RTC_CR_BKP);
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+}
+
+/**
+  * @brief  Daylight Saving Time, reads the store operation bit.
+  * @param  hrtc RTC handle
+  * @retval operation see RTC_StoreOperation_Definitions
+  */
+uint32_t HAL_RTC_DST_ReadStoreOperation(RTC_HandleTypeDef *hrtc)
+{
+  return READ_BIT(hrtc->Instance->CR, RTC_CR_BKP);
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTC_Exported_Functions_Group5 Peripheral State functions
+  * @brief    Peripheral State functions
+  *
+@verbatim
+ ===============================================================================
+                     ##### Peripheral State functions #####
+ ===============================================================================
+    [..]
+    This subsection provides functions allowing to
+      (+) Get RTC state
+
+@endverbatim
+  * @{
+  */
+/**
+  * @brief  Returns the RTC state.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL state
+  */
+HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc)
+{
+  return hrtc->State;
+}
+
+/**
+  * @}
+  */
+
+
+/**
+  * @}
+  */
+
+/** @addtogroup RTC_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Enters the RTC Initialization mode.
+  * @note   The RTC Initialization mode is write protected, use the
+  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
+{
+  uint32_t tickstart = 0U;
+  HAL_StatusTypeDef status = HAL_OK;
+
+  /* Check that Initialization mode is not already set */
+  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
+  {
+    /* Set INIT bit to enter Initialization mode */
+    SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
+
+    /* Get tick */
+    tickstart = HAL_GetTick();
+
+    /* Wait till RTC is in INIT state and if timeout is reached exit */
+    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
+    {
+      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+      {
+        /* Set RTC state */
+        hrtc->State = HAL_RTC_STATE_ERROR;
+        status = HAL_ERROR;
+      }
+    }
+  }
+
+  return status;
+}
+
+/**
+  * @brief  Exits the RTC Initialization mode.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
+{
+  HAL_StatusTypeDef status = HAL_OK;
+
+  /* Clear INIT bit to exit Initialization mode */
+  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
+
+  /* If CR_BYPSHAD bit = 0, wait for synchro */
+  if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
+  {
+    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
+    {
+      /* Set RTC state */
+      hrtc->State = HAL_RTC_STATE_ERROR;
+      status = HAL_ERROR;
+    }
+  }
+
+  return status;
+}
+
+/**
+  * @brief  Converts a 2-digit number from decimal to BCD format.
+  * @param  number decimal-formatted number (from 0 to 99) to be converted
+  * @retval Converted byte
+  */
+uint8_t RTC_ByteToBcd2(uint8_t number)
+{
+  uint32_t bcdhigh = 0U;
+
+  while (number >= 10U)
+  {
+    bcdhigh++;
+    number -= 10U;
+  }
+
+  return ((uint8_t)(bcdhigh << 4U) | number);
+}
+
+/**
+  * @brief  Converts a 2-digit number from BCD to decimal format.
+  * @param  number BCD-formatted number (from 00 to 99) to be converted
+  * @retval Converted word
+  */
+uint8_t RTC_Bcd2ToByte(uint8_t number)
+{
+  uint32_t tens = 0U;
+  tens = (((uint32_t)number & 0xF0U) >> 4U) * 10U;
+  return (uint8_t)(tens + ((uint32_t)number & 0x0FU));
+}
+
+/**
+  * @}
+  */
+
+#endif /* HAL_RTC_MODULE_ENABLED */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
diff --git a/Drivers/STM32WB0x_HAL_Driver/Src/stm32wb0x_hal_rtc_ex.c b/Drivers/STM32WB0x_HAL_Driver/Src/stm32wb0x_hal_rtc_ex.c
new file mode 100644
index 0000000..a42387a
--- /dev/null
+++ b/Drivers/STM32WB0x_HAL_Driver/Src/stm32wb0x_hal_rtc_ex.c
@@ -0,0 +1,837 @@
+/**
+  ******************************************************************************
+  * @file    stm32wb0x_hal_rtc_ex.c
+  * @author  MCD Application Team
+  * @brief   Extended RTC HAL module driver.
+  *          This file provides firmware functions to manage the following
+  *          functionalities of the Real-Time Clock (RTC) Extended peripheral:
+  *           + RTC Wakeup functions
+  *           + Extended Control functions
+  *           + Extended RTC features functions
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * Copyright (c) 2024 STMicroelectronics.
+  * All rights reserved.
+  *
+  * This software is licensed under terms that can be found in the LICENSE file
+  * in the root directory of this software component.
+  * If no LICENSE file comes with this software, it is provided AS-IS.
+  *
+  ******************************************************************************
+  @verbatim
+  ==============================================================================
+                        ##### How to use this driver #####
+  ==============================================================================
+  [..]
+    (+) Enable the RTC domain access.
+    (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour
+        format using the HAL_RTC_Init() function.
+
+  *** RTC Wakeup configuration ***
+  ================================
+  [..]
+    (+) To configure the RTC Wakeup Clock source and Counter use the
+        HAL_RTCEx_SetWakeUpTimer() function.
+        You can also configure the RTC Wakeup timer in interrupt mode using the
+        HAL_RTCEx_SetWakeUpTimer_IT() function.
+    (+) To read the RTC Wakeup Counter register, use the HAL_RTCEx_GetWakeUpTimer()
+        function.
+
+  *** Backup Data Registers configuration ***
+  ===========================================
+  [..]
+    (+) To write to the RTC Backup Data registers, use the HAL_RTCEx_BKUPWrite()
+        function.
+    (+) To read the RTC Backup Data registers, use the HAL_RTCEx_BKUPRead()
+        function.
+
+  *** Smooth Digital Calibration configuration ***
+  ================================================
+  [..]
+    (+) RTC frequency can be digitally calibrated with a resolution of about
+        0.954 ppm with a range from -487.1 ppm to +488.5 ppm.
+        The correction of the frequency is performed using a series of small
+        adjustments (adding and/or subtracting individual RTCCLK pulses).
+    (+) The smooth digital calibration is performed during a cycle of about 2^20
+        RTCCLK pulses (or 32 seconds) when the input frequency is 32,768 Hz.
+        This cycle is maintained by a 20-bit counter clocked by RTCCLK.
+    (+) The smooth calibration register (RTC_CALR) specifies the number of RTCCLK
+        clock cycles to be masked during the 32-second cycle.
+    (+) To configure the RTC Smooth Digital Calibration value and the corresponding
+        calibration cycle period (32s,16s and 8s) use the HAL_RTCEx_SetSmoothCalib()
+        function.
+
+  @endverbatim
+  ******************************************************************************
+  */
+
+/* Includes ------------------------------------------------------------------*/
+#include "stm32wb0x_hal.h"
+
+/** @addtogroup STM32WB0x_HAL_Driver
+  * @{
+  */
+
+/** @defgroup RTCEx RTCEx
+  * @brief    RTC Extended HAL module driver
+  * @{
+  */
+
+#ifdef HAL_RTC_MODULE_ENABLED
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Exported functions --------------------------------------------------------*/
+
+/** @defgroup RTCEx_Exported_Functions RTCEx Exported Functions
+  * @{
+  */
+
+/** @defgroup RTCEx_Exported_Functions_Group2 RTC Wakeup functions
+  * @brief    RTC Wakeup functions
+  *
+@verbatim
+ ===============================================================================
+                        ##### RTC Wakeup functions #####
+ ===============================================================================
+
+ [..] This section provides functions allowing to configure Wakeup feature
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Sets wakeup timer.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  WakeUpCounter Wakeup counter
+  * @param  WakeUpClock Wakeup clock
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
+{
+  uint32_t tickstart = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
+  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Check RTC WUTWF flag is reset only when wakeup timer enabled*/
+  if ((hrtc->Instance->CR & RTC_CR_WUTE) != 0U)
+  {
+    tickstart = HAL_GetTick();
+
+    /* Wait till RTC WUTWF flag is reset and if timeout is reached exit */
+    while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) != 0U)
+    {
+      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+      {
+        /* Enable the write protection for RTC registers */
+        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+        /* Process Unlocked */
+        __HAL_UNLOCK(hrtc);
+
+        return HAL_TIMEOUT;
+      }
+    }
+  }
+
+  /* Disable the Wakeup timer */
+  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
+
+  /* Clear the Wakeup flag */
+  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
+
+  /* Get tick */
+  tickstart = HAL_GetTick();
+
+  /* Wait till RTC WUTWF flag is set and if timeout is reached exit */
+  while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)
+  {
+    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+    {
+      /* Enable the write protection for RTC registers */
+      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+      hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+      /* Process Unlocked */
+      __HAL_UNLOCK(hrtc);
+
+      return HAL_TIMEOUT;
+    }
+  }
+
+  /* Clear the Wakeup Timer clock source bits in CR register */
+  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
+
+  /* Configure the clock source */
+  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
+
+  /* Configure the Wakeup Timer counter */
+  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
+
+  /* Enable the Wakeup Timer */
+  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Sets wakeup timer with interrupt.
+  * @note   The application must ensure that the RTC interrupt line is configured via HAL SYSCFG services and the PWR_WAKEUP_PIN_RTC bit is set.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  WakeUpCounter Wakeup counter
+  * @param  WakeUpClock Wakeup clock
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
+{
+  __IO uint32_t count  = RTC_TIMEOUT_VALUE * (SystemCoreClock / 32U / 1000U);
+
+  /* Check the parameters */
+  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
+  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Check RTC WUTWF flag is reset only when wakeup timer enabled */
+  if ((hrtc->Instance->CR & RTC_CR_WUTE) != 0U)
+  {
+    /* Wait till RTC WUTWF flag is reset and if timeout is reached exit */
+    do
+    {
+      count = count - 1U;
+      if (count == 0U)
+      {
+        /* Enable the write protection for RTC registers */
+        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+        /* Process Unlocked */
+        __HAL_UNLOCK(hrtc);
+
+        return HAL_TIMEOUT;
+      }
+    } while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) != 0U);
+  }
+
+  /* Disable the Wakeup timer */
+  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
+
+  /* Clear the Wakeup flag */
+  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
+
+  /* Reload the counter */
+  count = RTC_TIMEOUT_VALUE * (SystemCoreClock / 32U / 1000U);
+
+  /* Wait till RTC WUTWF flag is set and if timeout is reached exit */
+  do
+  {
+    count = count - 1U;
+    if (count == 0U)
+    {
+      /* Enable the write protection for RTC registers */
+      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+      hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+      /* Process Unlocked */
+      __HAL_UNLOCK(hrtc);
+
+      return HAL_TIMEOUT;
+    }
+  } while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U);
+
+  /* Clear the Wakeup Timer clock source bits in CR register */
+  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
+
+  /* Configure the clock source */
+  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
+
+  /* Configure the Wakeup Timer counter */
+  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
+
+  /* Configure the interrupt in the RTC_CR register */
+  __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc, RTC_IT_WUT);
+
+  /* Enable the Wakeup Timer */
+  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Deactivates wakeup timer counter.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
+{
+  uint32_t tickstart = 0U;
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Disable the Wakeup Timer */
+  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
+
+  /* In case of interrupt mode is used, the interrupt source must disabled */
+  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc, RTC_IT_WUT);
+
+  /* Get tick */
+  tickstart = HAL_GetTick();
+
+  /* Wait till RTC WUTWF flag is set and if timeout is reached exit */
+  while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == 0U)
+  {
+    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+    {
+      /* Enable the write protection for RTC registers */
+      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+      hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+      /* Process Unlocked */
+      __HAL_UNLOCK(hrtc);
+
+      return HAL_TIMEOUT;
+    }
+  }
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Gets wakeup timer counter.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval Counter value
+  */
+uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
+{
+  /* Get the counter value */
+  return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));
+}
+
+/**
+  * @brief  Handles Wakeup Timer interrupt request.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
+{
+  /* Get the pending status of the Wakeup timer Interrupt */
+  if (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != 0U)
+  {
+    /* Clear the Wakeup timer interrupt pending bit */
+    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
+
+    /* Wakeup timer callback */
+#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
+    hrtc->WakeUpTimerEventCallback(hrtc);
+#else
+    HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
+#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
+  }
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+}
+
+/**
+  * @brief  Wakeup Timer callback.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval None
+  */
+__weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
+{
+  /* Prevent unused argument(s) compilation warning */
+  UNUSED(hrtc);
+
+  /* NOTE: This function should not be modified, when the callback is needed,
+           the HAL_RTCEx_WakeUpTimerEventCallback could be implemented in the user file
+   */
+}
+
+/**
+  * @brief  Handles Wakeup Timer Polling.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  Timeout Timeout duration
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
+{
+  uint32_t tickstart = 0U;
+
+  /* Get tick */
+  tickstart = HAL_GetTick();
+
+  while (__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == 0U)
+  {
+    if (Timeout != HAL_MAX_DELAY)
+    {
+      if ((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
+      {
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+        return HAL_TIMEOUT;
+      }
+    }
+  }
+
+  /* Clear the Wakeup timer Flag */
+  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  return HAL_OK;
+}
+
+/**
+  * @}
+  */
+
+/** @defgroup RTCEx_Exported_Functions_Group3 Extended Peripheral Control functions
+  * @brief    Extended Peripheral Control functions
+  *
+@verbatim
+ ===============================================================================
+              ##### Extended Peripheral Control functions #####
+ ===============================================================================
+    [..]
+    This subsection provides functions allowing to
+      (+) Write a data in a specified RTC Backup data register
+      (+) Read a data in a specified RTC Backup data register
+      (+) Set the Smooth calibration parameters.
+      (+) Configure the Synchronization Shift Control Settings.
+      (+) Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
+      (+) Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
+      (+) Enable the RTC reference clock detection.
+      (+) Disable the RTC reference clock detection.
+      (+) Enable the Bypass Shadow feature.
+      (+) Disable the Bypass Shadow feature.
+
+@endverbatim
+  * @{
+  */
+
+/**
+  * @brief  Writes a data in a specified RTC Backup data register.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  BackupRegister RTC Backup data Register number.
+  *          This parameter can be: RTC_BKP_DRx (where x can be from 0 to 1)
+  *                                 to specify the register.
+  * @param  Data Data to be written in the specified RTC Backup data register.
+  * @retval None
+  */
+void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
+{
+  uint32_t tmp = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_BKP(BackupRegister));
+
+  tmp = (uint32_t) & (hrtc->Instance->BKP0R);
+  tmp += (BackupRegister * 4U);
+
+  /* Write the specified register */
+  *(__IO uint32_t *)tmp = (uint32_t)Data;
+}
+
+/**
+  * @brief  Reads data from the specified RTC Backup data Register.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  BackupRegister RTC Backup data Register number.
+  *          This parameter can be: RTC_BKP_DRx (where x can be from 0 to 1)
+  *                                 to specify the register.
+  * @retval Read value
+  */
+uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
+{
+  uint32_t tmp = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_BKP(BackupRegister));
+
+  tmp = (uint32_t) & (hrtc->Instance->BKP0R);
+  tmp += (BackupRegister * 4U);
+
+  /* Read the specified register */
+  return (*(__IO uint32_t *)tmp);
+}
+
+/**
+  * @brief  Sets the Smooth calibration parameters.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  SmoothCalibPeriod Select the Smooth Calibration Period.
+  *          This parameter can be can be one of the following values:
+  *             @arg RTC_SMOOTHCALIB_PERIOD_32SEC: The smooth calibration period is 32s.
+  *             @arg RTC_SMOOTHCALIB_PERIOD_16SEC: The smooth calibration period is 16s.
+  *             @arg RTC_SMOOTHCALIB_PERIOD_8SEC: The smooth calibration period is 8s.
+  * @param  SmoothCalibPlusPulses Select to Set or reset the CALP bit.
+  *          This parameter can be one of the following values:
+  *             @arg RTC_SMOOTHCALIB_PLUSPULSES_SET: Add one RTCCLK pulse every 2*11 pulses.
+  *             @arg RTC_SMOOTHCALIB_PLUSPULSES_RESET: No RTCCLK pulses are added.
+  * @param  SmoothCalibMinusPulsesValue Select the value of CALM[8:0] bits.
+  *          This parameter can be one any value from 0 to 0x000001FF.
+  * @note   To deactivate the smooth calibration, the field SmoothCalibPlusPulses
+  *         must be equal to SMOOTHCALIB_PLUSPULSES_RESET and the field
+  *         SmoothCalibMinusPulsesValue must be equal to 0.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue)
+{
+  uint32_t tickstart = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
+  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
+  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* check if a calibration is pending*/
+  if ((hrtc->Instance->ISR & RTC_ISR_RECALPF) != 0U)
+  {
+    /* Get tick */
+    tickstart = HAL_GetTick();
+
+    /* check if a calibration is pending*/
+    while ((hrtc->Instance->ISR & RTC_ISR_RECALPF) != 0U)
+    {
+      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+      {
+        /* Enable the write protection for RTC registers */
+        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+        /* Change RTC state */
+        hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+        /* Process Unlocked */
+        __HAL_UNLOCK(hrtc);
+
+        return HAL_TIMEOUT;
+      }
+    }
+  }
+
+  /* Configure the Smooth calibration settings */
+  hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod     | \
+                                    (uint32_t)SmoothCalibPlusPulses | \
+                                    (uint32_t)SmoothCalibMinusPulsesValue);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Configures the Synchronization Shift Control Settings.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  ShiftAdd1S Select to add or not 1 second to the time calendar.
+  *          This parameter can be one of the following values:
+  *             @arg RTC_SHIFTADD1S_SET: Add one second to the clock calendar.
+  *             @arg RTC_SHIFTADD1S_RESET: No effect.
+  * @param  ShiftSubFS Select the number of Second Fractions to substitute.
+  *          This parameter can be one any value from 0 to 0x7FFF.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
+{
+  uint32_t tickstart = 0U;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
+  assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Get tick */
+  tickstart = HAL_GetTick();
+
+  /* Wait until the shift is completed */
+  while ((hrtc->Instance->ISR & RTC_ISR_SHPF) != 0U)
+  {
+    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
+    {
+      /* Enable the write protection for RTC registers */
+      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+      hrtc->State = HAL_RTC_STATE_TIMEOUT;
+
+      /* Process Unlocked */
+      __HAL_UNLOCK(hrtc);
+
+      return HAL_TIMEOUT;
+    }
+  }
+
+  /* Configure the Shift settings */
+  hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
+
+  /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
+  if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
+  {
+    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
+    {
+      /* Enable the write protection for RTC registers */
+      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+      hrtc->State = HAL_RTC_STATE_ERROR;
+
+      /* Process Unlocked */
+      __HAL_UNLOCK(hrtc);
+
+      return HAL_ERROR;
+    }
+  }
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Configures the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @param  CalibOutput Select the Calibration output Selection.
+  *          This parameter can be one of the following values:
+  *             @arg RTC_CALIBOUTPUT_512HZ: A signal has a regular waveform at 512Hz.
+  *             @arg RTC_CALIBOUTPUT_1HZ: A signal has a regular waveform at 1Hz.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));
+
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Clear flags before config */
+  hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
+
+  /* Configure the RTC_CR register */
+  hrtc->Instance->CR |= (uint32_t)CalibOutput;
+
+  __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Deactivates the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc)
+{
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Enables the Bypass Shadow feature.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @note   When the Bypass Shadow is enabled the calendar value are taken
+  *         directly from the Calendar counter.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
+{
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Set the BYPSHAD bit */
+  hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @brief  Disables the Bypass Shadow feature.
+  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
+  *                the configuration information for RTC.
+  * @note   When the Bypass Shadow is enabled the calendar value are taken
+  *         directly from the Calendar counter.
+  * @retval HAL status
+  */
+HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc)
+{
+  /* Process Locked */
+  __HAL_LOCK(hrtc);
+
+  hrtc->State = HAL_RTC_STATE_BUSY;
+
+  /* Disable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
+
+  /* Reset the BYPSHAD bit */
+  hrtc->Instance->CR &= (uint8_t)~RTC_CR_BYPSHAD;
+
+  /* Enable the write protection for RTC registers */
+  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
+
+  /* Change RTC state */
+  hrtc->State = HAL_RTC_STATE_READY;
+
+  /* Process Unlocked */
+  __HAL_UNLOCK(hrtc);
+
+  return HAL_OK;
+}
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+#endif /* HAL_RTC_MODULE_ENABLED */
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
diff --git a/STM32_BLE/App/lockservice.c b/STM32_BLE/App/lockservice.c
index 8f98d81..04eb960 100644
--- a/STM32_BLE/App/lockservice.c
+++ b/STM32_BLE/App/lockservice.c
@@ -39,6 +39,7 @@ typedef struct{
   uint16_t  LockserviceSvcHdle;				/**< Lockservice Service Handle */
   uint16_t  ApptowdCharHdle;			/**< APPTOWD Characteristic Handle */
   uint16_t  DevicestatusCharHdle;			/**< DEVICESTATUS Characteristic Handle */
+  uint16_t  MotiondataCharHdle;			/**< MOTIONDATA Characteristic Handle */
 /* USER CODE BEGIN Context */
   /* Place holder for Characteristic Descriptors Handle*/
 
@@ -60,8 +61,9 @@ typedef struct{
 /* Private macros ------------------------------------------------------------*/
 #define CHARACTERISTIC_DESCRIPTOR_ATTRIBUTE_OFFSET        2
 #define CHARACTERISTIC_VALUE_ATTRIBUTE_OFFSET             1
-#define APPTOWD_SIZE        2	/* AppToWD Characteristic size */
+#define APPTOWD_SIZE        30	/* AppToWD Characteristic size */
 #define DEVICESTATUS_SIZE        2	/* DeviceStatus Characteristic size */
+#define MOTIONDATA_SIZE        8	/* MotionData Characteristic size */
 /* USER CODE BEGIN PM */
 
 /* USER CODE END PM */
@@ -94,6 +96,7 @@ extern volatile uint8_t deviceBattery;
 #define LOCKSERVICE_UUID			(0x183e)
 #define APPTOWD_UUID			0x20,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
 #define DEVICESTATUS_UUID			0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+#define MOTIONDATA_UUID			0x01,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
 
 BLE_GATT_SRV_CCCD_DECLARE(devicestatus, CFG_BLE_NUM_RADIO_TASKS, BLE_GATT_SRV_CCCD_PERM_DEFAULT,
                           BLE_GATT_SRV_OP_MODIFIED_EVT_ENABLE_FLAG);
@@ -120,6 +123,15 @@ static ble_gatt_val_buffer_def_t devicestatus_val_buffer_def = {
   .buffer_p = devicestatus_val_buffer
 };
 
+uint8_t motiondata_val_buffer[MOTIONDATA_SIZE];
+
+static ble_gatt_val_buffer_def_t motiondata_val_buffer_def = {
+  .op_flags = BLE_GATT_SRV_OP_MODIFIED_EVT_ENABLE_FLAG,
+  .val_len = MOTIONDATA_SIZE,
+  .buffer_len = sizeof(motiondata_val_buffer),
+  .buffer_p = motiondata_val_buffer
+};
+
 /* LockService service DEVICESTATUS (notification) characteristics definition */
 static const ble_gatt_chr_def_t lockservice_chars[] = {
 	{
@@ -140,6 +152,13 @@ static const ble_gatt_chr_def_t lockservice_chars[] = {
         },
         .val_buffer_p = &devicestatus_val_buffer_def
     },
+	{
+        .properties = BLE_GATT_SRV_CHAR_PROP_NONE,
+        .permissions = BLE_GATT_SRV_PERM_NONE,
+        .min_key_size = 0x10,
+        .uuid = BLE_UUID_INIT_128(MOTIONDATA_UUID),
+        .val_buffer_p = &motiondata_val_buffer_def
+    },
 };
 
 /* LockService service definition */
@@ -148,7 +167,7 @@ static const ble_gatt_srv_def_t lockservice_service = {
    .uuid = BLE_UUID_INIT_16(LOCKSERVICE_UUID),
    .chrs = {
        .chrs_p = (ble_gatt_chr_def_t *)lockservice_chars,
-       .chr_count = 2U,
+       .chr_count = 3U,
    },
 };
 
@@ -338,6 +357,7 @@ void LOCKSERVICE_Init(void)
   LOCKSERVICE_Context.LockserviceSvcHdle = aci_gatt_srv_get_service_handle((ble_gatt_srv_def_t *) &lockservice_service);
   LOCKSERVICE_Context.ApptowdCharHdle = aci_gatt_srv_get_char_decl_handle((ble_gatt_chr_def_t *)&lockservice_chars[0]);
   LOCKSERVICE_Context.DevicestatusCharHdle = aci_gatt_srv_get_char_decl_handle((ble_gatt_chr_def_t *)&lockservice_chars[1]);
+  LOCKSERVICE_Context.MotiondataCharHdle = aci_gatt_srv_get_char_decl_handle((ble_gatt_chr_def_t *)&lockservice_chars[2]);
 
   /* USER CODE BEGIN InitService1Svc_2 */
 
@@ -374,6 +394,13 @@ tBleStatus LOCKSERVICE_UpdateValue(LOCKSERVICE_CharOpcode_t CharOpcode, LOCKSERV
       /* USER CODE END Service1_Char_Value_1*/
       break;
 
+    case LOCKSERVICE_MOTIONDATA:
+      memcpy(motiondata_val_buffer, pData->p_Payload, MIN(pData->Length, sizeof(motiondata_val_buffer)));
+      /* USER CODE BEGIN Service1_Char_Value_3*/
+
+      /* USER CODE END Service1_Char_Value_3*/
+      break;
+
     default:
       break;
   }
diff --git a/STM32_BLE/App/lockservice.h b/STM32_BLE/App/lockservice.h
index c4edbb2..197906f 100644
--- a/STM32_BLE/App/lockservice.h
+++ b/STM32_BLE/App/lockservice.h
@@ -42,6 +42,7 @@ typedef enum
 {
   LOCKSERVICE_APPTOWD,
   LOCKSERVICE_DEVICESTATUS,
+  LOCKSERVICE_MOTIONDATA,
 
   /* USER CODE BEGIN Service1_CharOpcode_t */
 
diff --git a/STM32_BLE/App/lockservice_app.c b/STM32_BLE/App/lockservice_app.c
index 8891136..c68fa7a 100644
--- a/STM32_BLE/App/lockservice_app.c
+++ b/STM32_BLE/App/lockservice_app.c
@@ -30,6 +30,7 @@
 /* Private includes ----------------------------------------------------------*/
 /* USER CODE BEGIN Includes */
 #include "sound.h"
+#include "motion_logger.h"
 /* USER CODE END Includes */
 
 /* Private typedef -----------------------------------------------------------*/
@@ -81,13 +82,160 @@ uint8_t a_LOCKSERVICE_UpdateCharData[247];
 extern volatile uint8_t deviceState;
 extern volatile uint8_t deviceInfo;
 extern volatile uint8_t deviceBattery;
-//static uint8_t lastSentDeviceInfo = 0xFF;  // Track last sent value (0xFF = never sent)
+
+// Track current transfer state
+static uint16_t currentEventIndex = 0;
+static uint8_t transferInProgress = 0;
 /* USER CODE END PV */
 
 /* Private function prototypes -----------------------------------------------*/
 static void LOCKSERVICE_Devicestatus_SendNotification(void);
 
 /* USER CODE BEGIN PFP */
+/**
+ * @brief Send motion alert notification to iOS
+ * This triggers iOS to auto-sync
+ */
+void LOCKSERVICE_SendMotionAlert(void)
+{
+    if (LOCKSERVICE_APP_Context.ConnectionHandle == 0xFFFF) {
+        return;
+    }
+
+    // Send special alert byte: 0xFF
+    a_LOCKSERVICE_UpdateCharData[0] = 0xFF;  // Motion alert marker
+    a_LOCKSERVICE_UpdateCharData[1] = deviceBattery;
+
+    LOCKSERVICE_Data_t lockservice_notification_data;
+    lockservice_notification_data.p_Payload = (uint8_t*)a_LOCKSERVICE_UpdateCharData;
+    lockservice_notification_data.Length = 2;
+
+    LOCKSERVICE_NotifyValue(LOCKSERVICE_DEVICESTATUS, &lockservice_notification_data,
+                           LOCKSERVICE_APP_Context.ConnectionHandle);
+
+    printf(" Motion alert sent to iOS\n");
+}
+
+/**
+ * @brief Update RTC from iOS timestamp
+ * @param data Pointer to timestamp data (6 bytes: year, month, day, hour, minute, second)
+ */
+static void UpdateRTCFromiOS(uint8_t *timestamp_data)
+{
+    extern RTC_HandleTypeDef hrtc;  // Make sure hrtc is accessible
+
+    RTC_TimeTypeDef sTime = {0};
+    RTC_DateTypeDef sDate = {0};
+
+    // Extract timestamp from last 6 bytes
+    sDate.Year = timestamp_data[0];   // Year offset from 2000
+    sDate.Month = timestamp_data[1];
+    sDate.Date = timestamp_data[2];
+    sTime.Hours = timestamp_data[3];
+    sTime.Minutes = timestamp_data[4];
+    sTime.Seconds = timestamp_data[5];
+
+    // Set weekday (calculate or just use Monday)
+    sDate.WeekDay = RTC_WEEKDAY_MONDAY;
+
+    // Update RTC
+    HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
+    HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
+
+    printf(" RTC updated: 20%02d-%02d-%02d %02d:%02d:%02d\n",
+           sDate.Year, sDate.Month, sDate.Date,
+           sTime.Hours, sTime.Minutes, sTime.Seconds);
+}
+
+/**
+ * @brief Send event count to iOS
+ */
+static void LOCKSERVICE_SendEventCount(void)
+{
+    if (LOCKSERVICE_APP_Context.ConnectionHandle == 0xFFFF) {
+        return;
+    }
+
+    uint16_t eventCount = MotionLogger_GetEventCount();
+
+    a_LOCKSERVICE_UpdateCharData[0] = RESP_LOG_COUNT;
+    a_LOCKSERVICE_UpdateCharData[1] = (eventCount >> 8) & 0xFF;  // High byte
+    a_LOCKSERVICE_UpdateCharData[2] = eventCount & 0xFF;         // Low byte
+
+    LOCKSERVICE_Data_t lockservice_notification_data;
+    lockservice_notification_data.p_Payload = (uint8_t*)a_LOCKSERVICE_UpdateCharData;
+    lockservice_notification_data.Length = 3;
+
+    LOCKSERVICE_NotifyValue(LOCKSERVICE_DEVICESTATUS, &lockservice_notification_data,
+                           LOCKSERVICE_APP_Context.ConnectionHandle);
+}
+
+/**
+ * @brief Send specific event to iOS
+ * @param index Event index to send
+ */
+static void LOCKSERVICE_SendEvent(uint16_t index)
+{
+    if (LOCKSERVICE_APP_Context.ConnectionHandle == 0xFFFF) {
+        return;
+    }
+
+    MotionEvent_t *event = MotionLogger_GetEvent(index);
+
+    if (event == NULL) {
+        // No event at this index
+        a_LOCKSERVICE_UpdateCharData[0] = RESP_NO_MORE_EVENTS;
+        a_LOCKSERVICE_UpdateCharData[1] = (index >> 8) & 0xFF;
+        a_LOCKSERVICE_UpdateCharData[2] = index & 0xFF;
+
+        LOCKSERVICE_Data_t lockservice_notification_data;
+        lockservice_notification_data.p_Payload = (uint8_t*)a_LOCKSERVICE_UpdateCharData;
+        lockservice_notification_data.Length = 3;
+
+        LOCKSERVICE_NotifyValue(LOCKSERVICE_DEVICESTATUS, &lockservice_notification_data,
+                               LOCKSERVICE_APP_Context.ConnectionHandle);
+        return;
+    }
+
+    // Pack event data
+    uint8_t dataIdx = 0;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = RESP_EVENT_DATA;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = (index >> 8) & 0xFF;  // Index high byte
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = index & 0xFF;         // Index low byte
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->date.Year;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->date.Month;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->date.Date;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->time.Hours;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->time.Minutes;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->time.Seconds;
+    a_LOCKSERVICE_UpdateCharData[dataIdx++] = event->motionType;
+
+    LOCKSERVICE_Data_t lockservice_notification_data;
+    lockservice_notification_data.p_Payload = (uint8_t*)a_LOCKSERVICE_UpdateCharData;
+    lockservice_notification_data.Length = dataIdx;
+
+    LOCKSERVICE_NotifyValue(LOCKSERVICE_DEVICESTATUS, &lockservice_notification_data,
+                           LOCKSERVICE_APP_Context.ConnectionHandle);
+}
+
+/**
+ * @brief Send log cleared confirmation
+ */
+static void LOCKSERVICE_SendLogCleared(void)
+{
+    if (LOCKSERVICE_APP_Context.ConnectionHandle == 0xFFFF) {
+        return;
+    }
+
+    a_LOCKSERVICE_UpdateCharData[0] = RESP_LOG_CLEARED;
+
+    LOCKSERVICE_Data_t lockservice_notification_data;
+    lockservice_notification_data.p_Payload = (uint8_t*)a_LOCKSERVICE_UpdateCharData;
+    lockservice_notification_data.Length = 1;
+
+    LOCKSERVICE_NotifyValue(LOCKSERVICE_DEVICESTATUS, &lockservice_notification_data,
+                           LOCKSERVICE_APP_Context.ConnectionHandle);
+}
 
 /* USER CODE END PFP */
 
@@ -105,18 +253,53 @@ void LOCKSERVICE_Notification(LOCKSERVICE_NotificationEvt_t *p_Notification)
 
     case LOCKSERVICE_APPTOWD_WRITE_EVT:
       /* USER CODE BEGIN Service1Char1_WRITE_EVT */
-    	LOCKSERVICE_SendStatusUpdate();
-    	uint8_t *received_data = p_Notification->DataTransfered.p_Payload;
-    	uint8_t data_length = p_Notification->DataTransfered.Length;
-
-    	if(data_length > 0)
-    	{
-    	  // Simply set lockState to the received value
-    	  deviceState = received_data[0];
-    	  HAL_Delay(5);
-    	  LOCKSERVICE_ForceStatusUpdate();
-    	}
-    	break;
+        uint8_t *received_data = p_Notification->DataTransfered.p_Payload;
+        uint8_t data_length = p_Notification->DataTransfered.Length;
+
+        if(data_length > 0)
+        {
+            // Extract timestamp from last 6 bytes (if present)
+            if (data_length >= 7) {
+                UpdateRTCFromiOS(&received_data[data_length - 6]);
+            }
+
+            // Now process the command (first byte, or first N bytes before timestamp)
+            uint8_t command = received_data[0];
+
+            switch(command) {
+                case CMD_REQUEST_LOG_COUNT:
+                    transferInProgress = 1;
+                    currentEventIndex = 0;
+                    LOCKSERVICE_SendEventCount();
+                    break;
+
+                case CMD_REQUEST_EVENT:
+                    if (data_length >= 3) {
+                        uint16_t requestedIndex = ((uint16_t)received_data[1] << 8) | received_data[2];
+                        LOCKSERVICE_SendEvent(requestedIndex);
+                    }
+                    break;
+
+                case CMD_ACK_EVENT:
+                    // iOS acknowledged receiving event
+                    break;
+
+                case CMD_CLEAR_LOG:
+                    MotionLogger_Clear();
+                    transferInProgress = 0;
+                    currentEventIndex = 0;
+                    LOCKSERVICE_SendLogCleared();
+                    break;
+
+                default:
+                    // Regular device state update
+                    deviceState = received_data[0];
+                    HAL_Delay(5);
+                    LOCKSERVICE_ForceStatusUpdate();
+                    break;
+            }
+        }
+        break;
       /* USER CODE END Service1Char1_WRITE_EVT */
       break;
 
@@ -164,11 +347,11 @@ void LOCKSERVICE_APP_EvtRx(LOCKSERVICE_APP_ConnHandleNotEvt_t *p_Notification)
     case LOCKSERVICE_DISCON_HANDLE_EVT :
       LOCKSERVICE_APP_Context.ConnectionHandle = 0xFFFF;
       /* USER CODE BEGIN Service1_APP_DISCON_HANDLE_EVT */
-      playTone(880,10);
+      playTone(380,10);
       HAL_Delay(10);
-      playTone(780,12);
+      playTone(280,12);
       HAL_Delay(10);
-      playTone(700,15);
+      playTone(100,15);
       /* USER CODE END Service1_APP_DISCON_HANDLE_EVT */
       break;
 
diff --git a/STM32_BLE/App/lockservice_app.h b/STM32_BLE/App/lockservice_app.h
index 38cac1e..fb689e9 100644
--- a/STM32_BLE/App/lockservice_app.h
+++ b/STM32_BLE/App/lockservice_app.h
@@ -64,7 +64,17 @@ typedef struct
 
 /* External variables --------------------------------------------------------*/
 /* USER CODE BEGIN EV */
-
+/* BLE Command Definitions */
+#define CMD_REQUEST_LOG_COUNT    0xF0  // iOS: Request total event count
+#define CMD_REQUEST_EVENT        0xF1  // iOS: Request specific event by index
+#define CMD_CLEAR_LOG            0xF2  // iOS: Clear all events
+#define CMD_ACK_EVENT            0xF3  // iOS: Acknowledge received event
+
+/* Response Types */
+#define RESP_LOG_COUNT           0xE0  // WD: Sending log count
+#define RESP_EVENT_DATA          0xE1  // WD: Sending event data
+#define RESP_NO_MORE_EVENTS      0xE2  // WD: No event at requested index
+#define RESP_LOG_CLEARED         0xE3  // WD: Log cleared confirmation
 /* USER CODE END EV */
 
 /* Exported macros -----------------------------------------------------------*/
@@ -78,6 +88,7 @@ void LOCKSERVICE_APP_EvtRx(LOCKSERVICE_APP_ConnHandleNotEvt_t *p_Notification);
 /* USER CODE BEGIN EF */
 void LOCKSERVICE_SendStatusUpdate(void);
 void LOCKSERVICE_ForceStatusUpdate(void);
+void LOCKSERVICE_SendMotionAlert(void);
 /* USER CODE END EF */
 
 #ifdef __cplusplus
diff --git a/WatchDogBT.ioc b/WatchDogBT.ioc
index 7c31d4c..c48cba3 100644
--- a/WatchDogBT.ioc
+++ b/WatchDogBT.ioc
@@ -16,12 +16,13 @@ Mcu.IP1=COMMON_BLE
 Mcu.IP10=RADIO_TIMER
 Mcu.IP11=RCC
 Mcu.IP12=RNG
-Mcu.IP13=SEQUENCER
-Mcu.IP14=STM32_BLE
-Mcu.IP15=SYS
-Mcu.IP16=TIM2
-Mcu.IP17=TINY_LPM
-Mcu.IP18=USART1
+Mcu.IP13=RTC
+Mcu.IP14=SEQUENCER
+Mcu.IP15=STM32_BLE
+Mcu.IP16=SYS
+Mcu.IP17=TIM2
+Mcu.IP18=TINY_LPM
+Mcu.IP19=USART1
 Mcu.IP2=CORTEX_M0+
 Mcu.IP3=I2C1
 Mcu.IP4=MEMORYMAP
@@ -30,7 +31,7 @@ Mcu.IP6=NVIC
 Mcu.IP7=PKA
 Mcu.IP8=PWR
 Mcu.IP9=RADIO
-Mcu.IPNb=19
+Mcu.IPNb=20
 Mcu.Name=STM32WB05KZVx
 Mcu.Package=VFQFPN32
 Mcu.Pin0=PB3
@@ -47,12 +48,14 @@ Mcu.Pin18=VP_PWR_VS_SECSignals
 Mcu.Pin19=VP_RADIO_TIMER_VS_RADIO
 Mcu.Pin2=PA1
 Mcu.Pin20=VP_RNG_VS_RNG
-Mcu.Pin21=VP_SEQUENCER_VS_SEQUENCER
-Mcu.Pin22=VP_STM32_BLE_VS_BLE_HOST_SP
-Mcu.Pin23=VP_SYS_VS_Systick
-Mcu.Pin24=VP_TIM2_VS_ClockSourceINT
-Mcu.Pin25=VP_TINY_LPM_VS_TINY_LPM
-Mcu.Pin26=VP_MEMORYMAP_VS_MEMORYMAP
+Mcu.Pin21=VP_RTC_VS_RTC_Activate
+Mcu.Pin22=VP_RTC_VS_RTC_Calendar
+Mcu.Pin23=VP_SEQUENCER_VS_SEQUENCER
+Mcu.Pin24=VP_STM32_BLE_VS_BLE_HOST_SP
+Mcu.Pin25=VP_SYS_VS_Systick
+Mcu.Pin26=VP_TIM2_VS_ClockSourceINT
+Mcu.Pin27=VP_TINY_LPM_VS_TINY_LPM
+Mcu.Pin28=VP_MEMORYMAP_VS_MEMORYMAP
 Mcu.Pin3=PA0
 Mcu.Pin4=PA8
 Mcu.Pin5=PA9
@@ -60,7 +63,7 @@ Mcu.Pin6=RF1
 Mcu.Pin7=OSCOUT
 Mcu.Pin8=OSCIN
 Mcu.Pin9=PB14
-Mcu.PinsNb=27
+Mcu.PinsNb=29
 Mcu.ThirdPartyNb=0
 Mcu.UserConstants=
 Mcu.UserName=STM32WB05KZVx
@@ -144,7 +147,7 @@ ProjectManager.ToolChainLocation=
 ProjectManager.UAScriptAfterPath=
 ProjectManager.UAScriptBeforePath=
 ProjectManager.UnderRoot=true
-ProjectManager.functionlistsort=1-SystemClock_Config-RCC-false-HAL-false,2-MX_GPIO_Init-GPIO-false-HAL-true,3-MX_TIM2_Init-TIM2-false-HAL-true,4-MX_I2C1_Init-I2C1-false-HAL-true,5-MX_RNG_Init-RNG-false-HAL-true,6-MX_PKA_Init-PKA-false-HAL-true,7-MX_RADIO_Init-RADIO-false-HAL-true,8-MX_RADIO_TIMER_Init-RADIO_TIMER-false-HAL-true,9-APPE_Init-STM32_BLE-false-HAL-false,10-MX_USART1_UART_Init-USART1-true-HAL-false,0-MX_CORTEX_M0+_Init-CORTEX_M0+-false-HAL-true,0-MX_PWR_Init-PWR-false-HAL-true
+ProjectManager.functionlistsort=1-SystemClock_Config-RCC-false-HAL-false,2-MX_GPIO_Init-GPIO-false-HAL-true,3-MX_TIM2_Init-TIM2-false-HAL-true,4-MX_I2C1_Init-I2C1-false-HAL-true,5-MX_RNG_Init-RNG-false-HAL-true,6-MX_PKA_Init-PKA-false-HAL-true,7-MX_RADIO_Init-RADIO-false-HAL-true,8-MX_RADIO_TIMER_Init-RADIO_TIMER-false-HAL-true,9-APPE_Init-STM32_BLE-false-HAL-false,10-MX_USART1_UART_Init-USART1-true-HAL-false,11-MX_RTC_Init-RTC-false-HAL-true,0-MX_CORTEX_M0+_Init-CORTEX_M0+-false-HAL-true,0-MX_PWR_Init-PWR-false-HAL-true
 RADIO_TIMER.IPParameters=XTAL_StartupTime
 RADIO_TIMER.XTAL_StartupTime=1000
 RCC.BLEFreq_VALUE=32000000
@@ -171,6 +174,13 @@ RCC.SYSCLKSource=RCC_SYSCLKSOURCE_DIRECT_HSE
 RCC.SysCLKFreq_VALUE=32000000
 RF1.Mode=RF1_Activate
 RF1.Signal=RADIO_RF1
+RTC.Date=13
+RTC.Hours=11
+RTC.IPParameters=Date,Hours,Minutes,Year,Seconds,WeekDay
+RTC.Minutes=56
+RTC.Seconds=30
+RTC.WeekDay=RTC_WEEKDAY_TUESDAY
+RTC.Year=26
 SH.GPXTI0.0=GPIO_EXTI0
 SH.GPXTI0.ConfNb=1
 SH.S_TIM2_CH1.0=TIM2_CH1,PWM Generation1 CH1
@@ -206,7 +216,7 @@ STM32_BLE.CFG_BONDING_MODE=1
 STM32_BLE.CFG_FULL_LOW_POWER=0
 STM32_BLE.CFG_GAP_DEVICE_NAME=WatchDog
 STM32_BLE.CFG_LSCLK_LSE=1
-STM32_BLE.CFG_PUBLIC_BD_ADDRESS=0xF1D000000006
+STM32_BLE.CFG_PUBLIC_BD_ADDRESS=0xF1D000000014
 STM32_BLE.CFG_SCAN_INT_MS=250.0
 STM32_BLE.CFG_SCAN_WIN_MS=250.0
 STM32_BLE.CFG_TX_POWER=(0x1F) /* 0x1F <\=> 8 dBm */
@@ -214,7 +224,7 @@ STM32_BLE.CFG_TX_POWER_MODE=(1) /* Tx high power mode */
 STM32_BLE.INCLUDE_AD_TYPE_16_BIT_SERV_UUID_CMPLT_LIST=1
 STM32_BLE.INCLUDE_AD_TYPE_COMPLETE_LOCAL_NAME=1
 STM32_BLE.INCLUDE_AD_TYPE_MANUFACTURER_SPECIFIC_DATA=1
-STM32_BLE.IPParameters=INCLUDE_AD_TYPE_COMPLETE_LOCAL_NAME,AD_TYPE_COMPLETE_LOCAL_NAME,CFG_TX_POWER_MODE,CFG_TX_POWER,INCLUDE_AD_TYPE_MANUFACTURER_SPECIFIC_DATA,AD_TYPE_MANUFACTURER_DATA_NBR,CFG_GAP_DEVICE_NAME,ADV_LP_INTERVAL_MAX,ADV_LP_INTERVAL_MIN,CFG_LSCLK_LSE,AD_TYPE_MANUFACTURER_SPECIFIC_DATA_COMPANY_IDENTIFIER,AD_TYPE_MANUFACTURER_DATA_1,AD_TYPE_MANUFACTURER_DATA_2,AD_TYPE_MANUFACTURER_DATA_3,AD_TYPE_MANUFACTURER_DATA_4,AD_TYPE_MANUFACTURER_DATA_5,AD_TYPE_MANUFACTURER_DATA_6,AD_TYPE_MANUFACTURER_DATA_7,AD_TYPE_MANUFACTURER_DATA_8,NUMBER_OF_SERVICES,SERVICE1_LONG_NAME,SERVICE1_SHORT_NAME,SERVICE1_NUMBER_OF_CHARACTERISTICS,SERVICE1_CHAR1_LONG_NAME,SERVICE1_CHAR1_SHORT_NAME,SERVICE1_UUID,SERVICE1_CHAR1_UUID_128_INPUT_TYPE,SERVICE1_CHAR1_UUID,SERVICE1_CHAR1_VALUE_LENGTH,SERVICE1_CHAR1_LENGTH_CHARACTERISTIC,SERVICE1_CHAR1_PROP_READ,SERVICE1_CHAR1_PROP_WRITE_NO_RESP,SERVICE1_CHAR1_GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR1_GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR1_PROP_WRITE,SERVICE1_UUID_TYPE,SERVICE1_UUID_ALLOCATION_TYPE,INCLUDE_AD_TYPE_16_BIT_SERV_UUID_CMPLT_LIST,AD_SERVICE_CLASS_UUID_1,AD_SERVICE_CLASS_UUID_1_INV,SERVICE1_CHAR2_LONG_NAME,SERVICE1_CHAR2_SHORT_NAME,SERVICE1_CHAR2_UUID,SERVICE1_CHAR2_PROP_NOTIFY,SERVICE1_CHAR2_GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR2_GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR2_GATT_NOTIFY_ATTRIBUTE_WRITE,ADV_INTERVAL_MIN,ADV_INTERVAL_MIN_HEXA,ADV_INTERVAL_MAX,ADV_INTERVAL_MAX_HEXA,ADV_LP_INTERVAL_MIN_HEXA,ADV_LP_INTERVAL_MAX_HEXA,CFG_SCAN_INT_MS,CFG_SCAN_WIN_MS,SERVICE1_CHAR2_VALUE_LENGTH,CFG_PUBLIC_BD_ADDRESS,CFG_FULL_LOW_POWER,CFG_BONDING_MODE,ADV_FILTER
+STM32_BLE.IPParameters=INCLUDE_AD_TYPE_COMPLETE_LOCAL_NAME,AD_TYPE_COMPLETE_LOCAL_NAME,CFG_TX_POWER_MODE,CFG_TX_POWER,INCLUDE_AD_TYPE_MANUFACTURER_SPECIFIC_DATA,AD_TYPE_MANUFACTURER_DATA_NBR,CFG_GAP_DEVICE_NAME,ADV_LP_INTERVAL_MAX,ADV_LP_INTERVAL_MIN,CFG_LSCLK_LSE,AD_TYPE_MANUFACTURER_SPECIFIC_DATA_COMPANY_IDENTIFIER,AD_TYPE_MANUFACTURER_DATA_1,AD_TYPE_MANUFACTURER_DATA_2,AD_TYPE_MANUFACTURER_DATA_3,AD_TYPE_MANUFACTURER_DATA_4,AD_TYPE_MANUFACTURER_DATA_5,AD_TYPE_MANUFACTURER_DATA_6,AD_TYPE_MANUFACTURER_DATA_7,AD_TYPE_MANUFACTURER_DATA_8,NUMBER_OF_SERVICES,SERVICE1_LONG_NAME,SERVICE1_SHORT_NAME,SERVICE1_NUMBER_OF_CHARACTERISTICS,SERVICE1_CHAR1_LONG_NAME,SERVICE1_CHAR1_SHORT_NAME,SERVICE1_UUID,SERVICE1_CHAR1_UUID_128_INPUT_TYPE,SERVICE1_CHAR1_UUID,SERVICE1_CHAR1_VALUE_LENGTH,SERVICE1_CHAR1_LENGTH_CHARACTERISTIC,SERVICE1_CHAR1_PROP_READ,SERVICE1_CHAR1_PROP_WRITE_NO_RESP,SERVICE1_CHAR1_GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR1_GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR1_PROP_WRITE,SERVICE1_UUID_TYPE,SERVICE1_UUID_ALLOCATION_TYPE,INCLUDE_AD_TYPE_16_BIT_SERV_UUID_CMPLT_LIST,AD_SERVICE_CLASS_UUID_1,AD_SERVICE_CLASS_UUID_1_INV,SERVICE1_CHAR2_LONG_NAME,SERVICE1_CHAR2_SHORT_NAME,SERVICE1_CHAR2_UUID,SERVICE1_CHAR2_PROP_NOTIFY,SERVICE1_CHAR2_GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR2_GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP,SERVICE1_CHAR2_GATT_NOTIFY_ATTRIBUTE_WRITE,ADV_INTERVAL_MIN,ADV_INTERVAL_MIN_HEXA,ADV_INTERVAL_MAX,ADV_INTERVAL_MAX_HEXA,ADV_LP_INTERVAL_MIN_HEXA,ADV_LP_INTERVAL_MAX_HEXA,CFG_SCAN_INT_MS,CFG_SCAN_WIN_MS,SERVICE1_CHAR2_VALUE_LENGTH,CFG_PUBLIC_BD_ADDRESS,CFG_FULL_LOW_POWER,CFG_BONDING_MODE,ADV_FILTER,SERVICE1_CHAR3_LONG_NAME,SERVICE1_CHAR3_SHORT_NAME,SERVICE1_CHAR3_UUID,SERVICE1_CHAR3_VALUE_LENGTH
 STM32_BLE.NUMBER_OF_SERVICES=1
 STM32_BLE.SERVICE1_CHAR1_GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP=\ 
 STM32_BLE.SERVICE1_CHAR1_GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP=\ 
@@ -226,7 +236,7 @@ STM32_BLE.SERVICE1_CHAR1_PROP_WRITE_NO_RESP=\
 STM32_BLE.SERVICE1_CHAR1_SHORT_NAME=AppToWD
 STM32_BLE.SERVICE1_CHAR1_UUID=20 02
 STM32_BLE.SERVICE1_CHAR1_UUID_128_INPUT_TYPE=0
-STM32_BLE.SERVICE1_CHAR1_VALUE_LENGTH=2
+STM32_BLE.SERVICE1_CHAR1_VALUE_LENGTH=30
 STM32_BLE.SERVICE1_CHAR2_GATT_NOTIFY_ATTRIBUTE_WRITE=\ 
 STM32_BLE.SERVICE1_CHAR2_GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP=\ 
 STM32_BLE.SERVICE1_CHAR2_GATT_NOTIFY_WRITE_REQ_AND_WAIT_FOR_APPL_RESP=\ 
@@ -235,8 +245,12 @@ STM32_BLE.SERVICE1_CHAR2_PROP_NOTIFY=BLE_GATT_SRV_CHAR_PROP_NOTIFY
 STM32_BLE.SERVICE1_CHAR2_SHORT_NAME=DeviceStatus
 STM32_BLE.SERVICE1_CHAR2_UUID=00 09
 STM32_BLE.SERVICE1_CHAR2_VALUE_LENGTH=2
+STM32_BLE.SERVICE1_CHAR3_LONG_NAME=MotionData
+STM32_BLE.SERVICE1_CHAR3_SHORT_NAME=MotionData
+STM32_BLE.SERVICE1_CHAR3_UUID=01 33
+STM32_BLE.SERVICE1_CHAR3_VALUE_LENGTH=8
 STM32_BLE.SERVICE1_LONG_NAME=LockService
-STM32_BLE.SERVICE1_NUMBER_OF_CHARACTERISTICS=2
+STM32_BLE.SERVICE1_NUMBER_OF_CHARACTERISTICS=3
 STM32_BLE.SERVICE1_SHORT_NAME=LockService
 STM32_BLE.SERVICE1_UUID=18 3E
 STM32_BLE.SERVICE1_UUID_ALLOCATION_TYPE=Proprietary
@@ -276,6 +290,10 @@ VP_RADIO_TIMER_VS_RADIO.Mode=RADIO_Activate
 VP_RADIO_TIMER_VS_RADIO.Signal=RADIO_TIMER_VS_RADIO
 VP_RNG_VS_RNG.Mode=RNG_Activate
 VP_RNG_VS_RNG.Signal=RNG_VS_RNG
+VP_RTC_VS_RTC_Activate.Mode=RTC_Enabled
+VP_RTC_VS_RTC_Activate.Signal=RTC_VS_RTC_Activate
+VP_RTC_VS_RTC_Calendar.Mode=RTC_Calendar
+VP_RTC_VS_RTC_Calendar.Signal=RTC_VS_RTC_Calendar
 VP_SEQUENCER_VS_SEQUENCER.Mode=SEQUENCER_Enabled
 VP_SEQUENCER_VS_SEQUENCER.Signal=SEQUENCER_VS_SEQUENCER
 VP_STM32_BLE_VS_BLE_HOST_SP.Mode=BLE_Server
